/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "classes";

import "io/charset/charset";
import "browser/css/parser";
import "browser/css/selector";
import "browser/css/property";
import "browser/css/media_query";
import "browser/css/stylesheet";
import "util/string";

function css_parse(buf: String, charset: Charset): Stylesheet
{
	var par = parser_create(buf, charset);
	return css_parse(par);
}

function @css_parse(par: Parser): Stylesheet
{
	var sheet = Stylesheet::create();

	foreach (var rule in parse_stylesheet(par)) {
		//dump_rule(rule, 0);

		var name = rule.name;
		if (name) {
			name = name.to_lower_case();
			
			if (name == "media") {
				var buf = rule.prelude;
				rewind_buffer(buf);
				if (next_token(buf) != TOKEN_AT_KEYWORD) continue;
				var media = parse_media_query_list(buf);
				if (!media) continue;

				var block = rule.value as SimpleBlock;
				rewind_buffer(block);
				var media_sheet = css_parse(block);
				sheet.add_rule(MediaQueryRule::create(media, media_sheet));
				continue;
			}

			if (name == "import") {
				var buf = rule.prelude;
				rewind_buffer(buf);
				if (next_token(buf) != TOKEN_AT_KEYWORD) continue;

				consume_whitespace(buf);

				var token = next_token(buf);
				if (token != TOKEN_URL && token != TOKEN_STRING) {
					continue;
				}
				var url = buf.value as String;

				consume_whitespace(buf);

				var media = parse_media_query_list(buf);

				consume_whitespace(buf);
				if (next_token(buf) != TOKEN_EOF) {
					continue;
				}

				sheet.add_rule(ImportRule::create(url, media));
				continue;
			}

			log("unhandled at-rule: "+name);
			continue;
		}

		var buf = rule.prelude;
		rewind_buffer(buf);
		var (group, e) = parse_selectors_group(buf);
		if (e) {
			//dump(e);
			continue;
		}
		
		//dump_selector_group(group);
		//log(serialize_selector_group(group));

		var block = rule.value as SimpleBlock;
		rewind_buffer(block);

		var decls = parse_list_of_declarations(block);
		var props = parse_properties(decls);

		sheet.add_rule(SelectorRule::create(group, props));
	}

	//log(sheet.to_string());
	return sheet;
}

function css_parse_inline_style(buf: String): Property[]
{
	var par = parser_create(buf, null);
	var decls = parse_list_of_declarations(par);
	var props = parse_properties(decls);
	return props;
}

function css_parse_media_query(buf: String): MediaQuery
{
	var par = parser_create(buf, null);
	var comps = parse_list_of_component_values(par);
	var media = parse_media_query_list(comps);
	return media;
}

function css_parse_selectors_group(buf: String): Selector[]
{
	var par = parser_create(buf, null);
	var comps = parse_list_of_component_values(par);
	var group = parse_selectors_group(comps);
	return group;
}

function css_parse_selector(buf: String): Selector
{
	var group = css_parse_selectors_group(buf);
	if (group.length != 1) {
		throw error("must contain single selector");
	}
	return group[0];
}

function @consume_whitespace(par: Parser)
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	back_token(par);
}
