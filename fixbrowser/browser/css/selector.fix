/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "string_switch";
use "classes";

import "browser/css/parser";
import "util/string";

// note: synchronize with native code
const {
	SEL_TYPE,
	SEL_ID,
	SEL_CLASS,
	SEL_ATTRIB,
	SEL_ATTRIB_PREFIX,
	SEL_ATTRIB_SUFFIX,
	SEL_ATTRIB_SUBSTRING,
	SEL_ATTRIB_EXACT,
	SEL_ATTRIB_INCLUDE,
	SEL_ATTRIB_DASH,
	SEL_PSEUDO_ELEMENT,
	SEL_PSEUDO_CLASS,
	SEL_FUNCTION_IDENT,
	SEL_FUNCTION_STRING,
	SEL_FUNCTION_ANB,
	SEL_NOT,
	SEL_SEQUENCE,

	COMB_DESCENDANT,
	COMB_CHILD,
	COMB_NEXT_SIBLING,
	COMB_SUBSEQUENT_SIBLING
};

// note: synchronize Selector classes with native code

class Selector
{
	var type: Integer;

	constructor @create(type: Integer)
	{
		this.type = type;
	}
}

class TypeSelector: Selector
{
	var namespace: String;
	var name: String;

	constructor create(namespace: String, name: String)
	{
		super::create(SEL_TYPE);
		this.namespace = namespace;
		this.name = name;
	}
}

class IDSelector: Selector
{
	var name: String;

	constructor @create(name: String)
	{
		super::create(SEL_ID);
		this.name = name;
	}
}

class ClassSelector: Selector
{
	var name: String;

	constructor @create(name: String)
	{
		super::create(SEL_CLASS);
		this.name = name;
	}
}

class AttribSelector: Selector
{
	var namespace: String;
	var name: String;
	var value: String;

	constructor @create(type: Integer, namespace: String, name: String, value: String)
	{
		super::create(type);
		this.namespace = namespace;
		this.name = name;
		this.value = value;
	}
}

class PseudoSelector: Selector
{
	var name: String;

	constructor @create(type: Integer, name: String)
	{
		super::create(type);
		this.name = name;
	}
}

class FunctionSelector: Selector
{
	var name: String;
	var expr: Dynamic;

	constructor @create(type: Integer, name: String, expr: Dynamic)
	{
		super::create(type);
		this.name = name;
		this.expr = expr;
	}
}

class NotSelector: Selector
{
	var selector: Selector;

	constructor @create(selector: Selector)
	{
		super::create(SEL_NOT);
		this.selector = selector;
	}
}

class SequenceSelector: Selector
{
	var selectors: Selector[];

	constructor @create(selectors: Selector[])
	{
		super::create(SEL_SEQUENCE);
		this.selectors = selectors;
	}
}

class CombinatorSelector: Selector
{
	var first: Selector;
	var second: Selector;

	constructor create(type: Integer, first: Selector, second: Selector)
	{
		super::create(type);
		this.first = first;
		this.second = second;
	}
}

function @consume_whitespace(par: Parser): Boolean
{
	var present = false;
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
		present = true;
	}
	back_token(par);
	return present;
}

function parse_selectors_group(par: Parser): Selector[]
{
	var group: Selector[] = [];
	
	group[] = parse_selector(par);

	for (;;) {
		consume_whitespace(par);

		var token = next_token(par);
		if (token == TOKEN_EOF) break;
		if (token != TOKEN_COMMA) {
			throw error("syntax error");
		}

		consume_whitespace(par);
		group[] = parse_selector(par);
	}

	return group;
}

function @parse_selector(par: Parser): Selector
{
	var selector = parse_simple_selector_sequence(par);

	for (;;) {
		var ws = consume_whitespace(par);

		var token = next_token(par);
		if (token == TOKEN_EOF || token == TOKEN_COMMA) {
			back_token(par);
			break;
		}

		if (token == TOKEN_DELIM) {
			switch (par.value as Integer) {
				case '+':
					consume_whitespace(par);
					selector = CombinatorSelector::create(COMB_NEXT_SIBLING, selector, parse_simple_selector_sequence(par));
					continue;

				case '>':
					consume_whitespace(par);
					selector = CombinatorSelector::create(COMB_CHILD, selector, parse_simple_selector_sequence(par));
					continue;

				case '~':
					consume_whitespace(par);
					selector = CombinatorSelector::create(COMB_SUBSEQUENT_SIBLING, selector, parse_simple_selector_sequence(par));
					continue;
			}
		}

		if (ws) {
			back_token(par);
			selector = CombinatorSelector::create(COMB_DESCENDANT, selector, parse_simple_selector_sequence(par));
			continue;
		}

		throw error("syntax error");
	}

	return selector;
}

function @parse_simple_selector_sequence(par: Parser): Selector
{
	var selectors: Selector[] = [];
	
	var sel = parse_type_selector(par);
	if (sel) selectors[] = sel;

	if (selectors.length == 0) {
		sel = parse_additional_selector(par, true);
		if (!sel) {
			throw error("syntax error");
		}
		selectors[] = sel;
	}

	while ((sel = parse_additional_selector(par, true))) {
		selectors[] = sel;
	}

	if (selectors.length == 1) {
		return selectors[0];
	}

	return SequenceSelector::create(selectors);
}

function @parse_type_selector(par: Parser): Selector
{
	var namespace: String, name: String;

	var token = next_token(par);
	if (token == TOKEN_DELIM && (par.value as Integer) == '|') {
		back_token(par);
	}
	else {
		if (token == TOKEN_IDENT) {
			name = par.value as String;
		}
		else if (token == TOKEN_DELIM && (par.value as Integer) == '*') {
			name = "*";
		}
		else {
			back_token(par);
			return null;
		}
	}

	token = next_token(par);
	if (token == TOKEN_DELIM && (par.value as Integer) == '|') {
		namespace = name;

		token = next_token(par);
		if (token == TOKEN_IDENT) {
			name = par.value as String;
		}
		else if (token == TOKEN_DELIM && (par.value as Integer) == '*') {
			name = "*";
		}
		else {
			throw error("syntax error");
		}
	}
	else {
		back_token(par);
	}

	return TypeSelector::create(namespace? namespace.to_lower_case() : null, name.to_lower_case());
}

function @parse_additional_selector(par: Parser, handle_not: Boolean): Selector
{
	var token = next_token(par);
	if (token == TOKEN_HASH) {
		return IDSelector::create(par.value as String);
	}
	else if (token == TOKEN_DELIM && (par.value as Integer) == '.') {
		token = next_token(par);
		if (token != TOKEN_IDENT) {
			throw error("syntax error");
		}
		return ClassSelector::create(par.value as String);
	}
	else if (token == COMPONENT_SIMPLE_BLOCK && (par.value as SimpleBlock).associated_token == TOKEN_SQUARE_LBRACKET) {
		var block = par.value as SimpleBlock;
		rewind_buffer(block);

		consume_whitespace(block);

		var namespace: String, name: String;

		token = next_token(block);
		if (token == TOKEN_DELIM && (block.value as Integer) == '*') {
			namespace = "*";
			token = next_token(block);
			if (token == TOKEN_DELIM && (block.value as Integer) == '|') {
				token = next_token(block);
				if (token == TOKEN_IDENT) {
					name = block.value as String;
				}
				else {
					throw error("syntax error");
				}
			}
			else {
				throw error("syntax error");
			}
		}
		else {
			if (token == TOKEN_IDENT) {
				name = block.value as String;

				token = next_token(block);
				if (token == TOKEN_DELIM && (block.value as Integer) == '|') {
					namespace = name;
					token = next_token(block);
					if (token != TOKEN_IDENT) {
						throw error("syntax error");
					}
					name = block.value as String;
				}
				else {
					back_token(block);
				}
			}
			else if (token == TOKEN_DELIM && (block.value as Integer) == '|') {
				token = next_token(block);
				if (token != TOKEN_IDENT) {
					throw error("syntax error");
				}
				name = block.value as String;
			}
			else {
				throw error("syntax error");
			}
		}

		consume_whitespace(block);
		
		token = next_token(block);
		if (token == TOKEN_EOF) {
			return AttribSelector::create(SEL_ATTRIB, namespace? namespace.to_lower_case() : null, name.to_lower_case(), null);
		}

		var type = -1;
		switch (token) {
			case TOKEN_PREFIX_MATCH: type = SEL_ATTRIB_PREFIX; break;
			case TOKEN_SUFFIX_MATCH: type = SEL_ATTRIB_SUFFIX; break;
			case TOKEN_SUBSTRING_MATCH: type = SEL_ATTRIB_SUBSTRING; break;

			case TOKEN_DELIM:
				if ((block.value as Integer) == '=') {
					type = SEL_ATTRIB_EXACT;
				}
				break;
				
			case TOKEN_INCLUDE_MATCH: type = SEL_ATTRIB_INCLUDE; break;
			case TOKEN_DASH_MATCH: type = SEL_ATTRIB_DASH; break;
		}

		if (type == -1) {
			throw error("syntax error");
		}

		consume_whitespace(block);

		var value: String;
		token = next_token(block);
		if (token == TOKEN_IDENT || token == TOKEN_STRING) {
			value = block.value as String;
		}
		else {
			throw error("syntax error");
		}

		consume_whitespace(block);
		token = next_token(block);
		if (token != TOKEN_EOF) {
			throw error("syntax error");
		}

		return AttribSelector::create(type, namespace? namespace.to_lower_case() : null, name.to_lower_case(), value);
	}
	else if (token == TOKEN_COLON) {
		var double = false;
		token = next_token(par);
		if (token == TOKEN_COLON) {
			double = true;
			token = next_token(par);
		}

		if (token == TOKEN_IDENT) {
			var name = par.value as String;
			if (!double && is_compat_pseudo_element(name)) {
				double = true;
			}
			return PseudoSelector::create(double? SEL_PSEUDO_ELEMENT : SEL_PSEUDO_CLASS, name.to_lower_case());
		}

		if (double || token != COMPONENT_FUNCTION) {
			throw error("syntax error");
		}

		var func = par.value as Function;
		var name = func.name.to_lower_case();

		rewind_buffer(func);
		consume_whitespace(func);

		if (handle_not && name.length == 3 && name.to_lower_case() == "not") {
			var not_sel = parse_type_selector(func);
			if (!not_sel) {
				not_sel = parse_additional_selector(func, false);
				if (!not_sel) throw error("syntax error");
			}

			consume_whitespace(func);

			token = next_token(func);
			if (token != TOKEN_EOF) {
				throw error("syntax error");
			}

			return NotSelector::create(not_sel);
		}

		var sel: Selector;

		token = next_token(func);

		if (is_anb_syntax_start(func)) {
			back_token(func);
			sel = FunctionSelector::create(SEL_FUNCTION_ANB, name, parse_anb_syntax(func));
		}
		else if (token == TOKEN_IDENT) {
			sel = FunctionSelector::create(SEL_FUNCTION_IDENT, name, func.value as String);
		}
		else if (token == TOKEN_STRING) {
			sel = FunctionSelector::create(SEL_FUNCTION_STRING, name, func.value as String);
		}

		if (!sel) {
			throw error("syntax error");
		}

		consume_whitespace(func);

		token = next_token(func);
		if (token != TOKEN_EOF) {
			throw error("syntax error");
		}

		return sel;
	}

	back_token(par);
	return null;
}

function @is_compat_pseudo_element(name: String): Boolean
{
	switch (name.to_lower_case()) {
		case "before":       return true;
		case "after":        return true;
		case "first-line":   return true;
		case "first-letter": return true;
	}
	return false;
}

function dump_selector_group(group: Selector[])
{
	for (var i=0; i<group.length; i++) {
		log("group "+i+":");
		dump_selector(group[i], 1);
	}
}

function @str(s: String): String
{
	if (!s) return "(none)";
	return "'"+s+"'";
}

function dump_selector(sel: Selector, level: Integer)
{
	var prefix = {""};
	for (var i=0; i<level; i++) {
		prefix[] = ' ';
		prefix[] = ' ';
	}

	switch (sel.type) {
		case SEL_TYPE:
			log(prefix+"type ns="+str((sel as TypeSelector).namespace)+" name="+str((sel as TypeSelector).name));
			break;

		case SEL_ID:
			log(prefix+"id name="+str((sel as IDSelector).name));
			break;

		case SEL_CLASS:
			log(prefix+"class name="+str((sel as ClassSelector).name));
			break;

		case SEL_ATTRIB:
			log(prefix+"attrib ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name));
			break;

		case SEL_ATTRIB_PREFIX:
			log(prefix+"attrib prefix ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_ATTRIB_SUFFIX:
			log(prefix+"attrib suffix ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_ATTRIB_SUBSTRING:
			log(prefix+"attrib substring ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_ATTRIB_EXACT:
			log(prefix+"attrib exact ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_ATTRIB_INCLUDE:
			log(prefix+"attrib include ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_ATTRIB_DASH:
			log(prefix+"attrib dash ns="+str((sel as AttribSelector).namespace)+" name="+str((sel as AttribSelector).name)+" value="+str((sel as AttribSelector).value));
			break;

		case SEL_PSEUDO_ELEMENT:
			log(prefix+"pseudo element name="+str((sel as PseudoSelector).name));
			break;

		case SEL_PSEUDO_CLASS:
			log(prefix+"pseudo class name="+str((sel as PseudoSelector).name));
			break;

		case SEL_FUNCTION_IDENT:
			log(prefix+"function name="+str((sel as FunctionSelector).name)+" ident="+(sel as FunctionSelector).expr);
			break;

		case SEL_FUNCTION_STRING:
			log(prefix+"function name="+str((sel as FunctionSelector).name)+" string="+str((sel as FunctionSelector).expr));
			break;

		case SEL_FUNCTION_ANB:
			log(prefix+"function name="+str((sel as FunctionSelector).name)+" anb="+serialize_anb_syntax((sel as FunctionSelector).expr));
			break;

		case SEL_NOT:
			log(prefix+"negation:");
			dump_selector((sel as NotSelector).selector, level+1);
			break;

		case SEL_SEQUENCE:
			log(prefix+"sequence:");
			foreach (var s in (sel as SequenceSelector).selectors) {
				dump_selector(s, level+1);
			}
			break;

		case COMB_DESCENDANT:
			log(prefix+"descendant combinator:");
			dump_selector((sel as CombinatorSelector).first, level+1);
			dump_selector((sel as CombinatorSelector).second, level+1);
			break;

		case COMB_CHILD:
			log(prefix+"child combinator:");
			dump_selector((sel as CombinatorSelector).first, level+1);
			dump_selector((sel as CombinatorSelector).second, level+1);
			break;

		case COMB_NEXT_SIBLING:
			log(prefix+"next sibling combinator:");
			dump_selector((sel as CombinatorSelector).first, level+1);
			dump_selector((sel as CombinatorSelector).second, level+1);
			break;

		case COMB_SUBSEQUENT_SIBLING:
			log(prefix+"subsequent sibling combinator:");
			dump_selector((sel as CombinatorSelector).first, level+1);
			dump_selector((sel as CombinatorSelector).second, level+1);
			break;

		default:
			log(prefix+"unknown selector type "+sel.type);
			break;
	}
}

function @serialize_selector(s: String, sel: Selector)
{
	switch (sel.type) {
		case SEL_TYPE:
			s += css_serialize_type((sel as TypeSelector).name);
			break;

		case SEL_ID:
			s[] = '#';
			s += css_escape((sel as IDSelector).name);
			break;

		case SEL_CLASS:
			s[] = '.';
			s += css_escape((sel as ClassSelector).name);
			break;

		case SEL_ATTRIB:
		case SEL_ATTRIB_PREFIX:
		case SEL_ATTRIB_SUFFIX:
		case SEL_ATTRIB_SUBSTRING:
		case SEL_ATTRIB_EXACT:
		case SEL_ATTRIB_INCLUDE:
		case SEL_ATTRIB_DASH:
			s[] = '[';
			if ((sel as AttribSelector).namespace) {
				s += css_serialize_namespace((sel as AttribSelector).namespace);
				s[] = '|';
			}
			s += css_escape((sel as AttribSelector).name);
			if (sel.type != SEL_ATTRIB) {
				switch (sel.type) {
					case SEL_ATTRIB_PREFIX:    s += "^="; break;
					case SEL_ATTRIB_SUFFIX:    s += "$="; break;
					case SEL_ATTRIB_SUBSTRING: s += "*="; break;
					case SEL_ATTRIB_EXACT:     s += "="; break;
					case SEL_ATTRIB_INCLUDE:   s += "~="; break;
					case SEL_ATTRIB_DASH:      s += "|="; break;
				}
				s += css_serialize_string((sel as AttribSelector).value);
			}
			s[] = ']';
			break;

		case SEL_PSEUDO_ELEMENT:
			s[] = ':';
			if (!is_compat_pseudo_element((sel as PseudoSelector).name)) {
				s[] = ':';
			}
			s += css_escape((sel as PseudoSelector).name);
			break;

		case SEL_PSEUDO_CLASS:
			s[] = ':';
			s += css_escape((sel as PseudoSelector).name);
			break;

		case SEL_FUNCTION_IDENT:
			s[] = ':';
			s += css_escape((sel as FunctionSelector).name);
			s[] = '(';
			s += css_escape((sel as FunctionSelector).expr as String);
			s[] = ')';
			break;

		case SEL_FUNCTION_STRING:
			s[] = ':';
			s += css_escape((sel as FunctionSelector).name);
			s[] = '(';
			s += css_serialize_string((sel as FunctionSelector).expr as String);
			s[] = ')';
			break;

		case SEL_FUNCTION_ANB:
			s[] = ':';
			s += css_escape((sel as FunctionSelector).name);
			s[] = '(';
			s += serialize_anb_syntax((sel as FunctionSelector).expr as ANB);
			s[] = ')';
			break;

		case SEL_NOT:
			s += ":not(";
			serialize_selector(s, (sel as NotSelector).selector);
			s[] = ')';
			break;

		case SEL_SEQUENCE:
			foreach (var sel2 in (sel as SequenceSelector).selectors) {
				serialize_selector(s, sel2);
			}
			break;

		case COMB_DESCENDANT:
			serialize_selector(s, (sel as CombinatorSelector).first);
			s[] = ' ';
			serialize_selector(s, (sel as CombinatorSelector).second);
			break;

		case COMB_CHILD:
			serialize_selector(s, (sel as CombinatorSelector).first);
			s[] = ' ';
			s[] = '>';
			s[] = ' ';
			serialize_selector(s, (sel as CombinatorSelector).second);
			break;

		case COMB_NEXT_SIBLING:
			serialize_selector(s, (sel as CombinatorSelector).first);
			s[] = ' ';
			s[] = '+';
			s[] = ' ';
			serialize_selector(s, (sel as CombinatorSelector).second);
			break;

		case COMB_SUBSEQUENT_SIBLING:
			serialize_selector(s, (sel as CombinatorSelector).first);
			s[] = ' ';
			s[] = '~';
			s[] = ' ';
			serialize_selector(s, (sel as CombinatorSelector).second);
			break;

		default:
			throw error("unknown selector type "+sel.type);
	}
}

function serialize_selector(sel: Selector): String
{
	var s = {""};
	serialize_selector(s, sel);
	return s;
}

function serialize_selector_group(group: Selector[]): String
{
	var s = {""};
	foreach (var sel in group) {
		if (s.length > 0) {
			s[] = ',';
			s[] = ' ';
		}
		serialize_selector(s, sel);
	}
	return s;
}

function selector_get_child_count(sel: Selector): Integer
{
	switch (sel.type) {
		case SEL_NOT:
			return 1;
			
		case SEL_SEQUENCE:
			return (sel as SequenceSelector).selectors.length;

		case COMB_DESCENDANT:
		case COMB_CHILD:
		case COMB_NEXT_SIBLING:
		case COMB_SUBSEQUENT_SIBLING:
			return 2;
	}
	return 0;
}

function selector_get_child(sel: Selector, idx: Integer): Selector
{
	switch (sel.type) {
		case SEL_NOT:
			if (idx == 0) return (sel as NotSelector).selector;
			break;
			
		case SEL_SEQUENCE:
			return (sel as SequenceSelector).selectors[idx];

		case COMB_DESCENDANT:
		case COMB_CHILD:
		case COMB_NEXT_SIBLING:
		case COMB_SUBSEQUENT_SIBLING:
			if (idx == 0) return (sel as CombinatorSelector).first;
			if (idx == 1) return (sel as CombinatorSelector).second;
			break;
	}
	throw error("invalid child selector index");
}
