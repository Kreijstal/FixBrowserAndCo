/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "classes";

import "browser/css/parser";
import "util/string";

const {
	VALUE_INITIAL,
	VALUE_INHERIT,
	VALUE_UNSET,
	VALUE_NONE,

	// background image repeat:
	VALUE_REPEAT,
	VALUE_NO_REPEAT,
	VALUE_SPACE,
	VALUE_ROUND,

	// background attachment:
	VALUE_FIXED,
	VALUE_LOCAL,
	VALUE_SCROLL,

	// background position:
	VALUE_LEFT,
	VALUE_CENTER,
	VALUE_RIGHT,
	VALUE_TOP,
	VALUE_BOTTOM,

	// background clip:
	VALUE_BORDER_BOX,
	VALUE_PADDING_BOX,
	VALUE_CONTENT_BOX,

	// background size:
	VALUE_COVER,
	VALUE_CONTAIN,
	VALUE_AUTO,

	// border style:
	//VALUE_NONE,
	VALUE_HIDDEN,
	VALUE_DOTTED,
	VALUE_DASHED,
	VALUE_SOLID,
	VALUE_DOUBLE,
	VALUE_GROOVE,
	VALUE_RIDGE,
	VALUE_INSET,
	VALUE_OUTSET,

	// border width:
	VALUE_THIN,
	VALUE_MEDIUM,
	VALUE_THICK,

	// border collapse:
	VALUE_COLLAPSE,
	VALUE_SEPARATE,

	// font weight:
	VALUE_BOLDER,
	VALUE_LIGHTER,

	// font style:
	VALUE_NORMAL,
	VALUE_ITALIC,
	VALUE_OBLIQUE,

	// font size:
	VALUE_XX_SMALL,
	VALUE_X_SMALL,
	VALUE_SMALL,
	//VALUE_MEDIUM,
	VALUE_LARGE,
	VALUE_X_LARGE,
	VALUE_XX_LARGE,
	VALUE_LARGER,
	VALUE_SMALLER,

	// display:
	VALUE_INLINE,
	VALUE_BLOCK,
	VALUE_LIST_ITEM,
	VALUE_INLINE_BLOCK,
	VALUE_TABLE,
	VALUE_INLINE_TABLE,
	VALUE_TABLE_ROW_GROUP,
	VALUE_TABLE_HEADER_GROUP,
	VALUE_TABLE_FOOTER_GROUP,
	VALUE_TABLE_ROW,
	VALUE_TABLE_COLUMN_GROUP,
	VALUE_TABLE_COLUMN,
	VALUE_TABLE_CELL,
	VALUE_TABLE_CAPTION,
	VALUE_FLEX,
	VALUE_INLINE_FLEX,
	//VALUE_NONE,

	// position:
	VALUE_STATIC,
	VALUE_RELATIVE,
	VALUE_ABSOLUTE,
	//VALUE_FIXED,

	// float:
	//VALUE_LEFT,
	//VALUE_RIGHT,
	//VALUE_NONE,

	// clear:
	//VALUE_NONE,
	//VALUE_LEFT,
	//VALUE_RIGHT,
	VALUE_BOTH,

	// vertical align:
	VALUE_BASELINE,
	VALUE_SUB,
	VALUE_SUPER,
	//VALUE_TOP,
	VALUE_TEXT_TOP,
	VALUE_MIDDLE,
	//VALUE_BOTTOM,
	VALUE_TEXT_BOTTOM,

	// text align:
	//VALUE_LEFT,
	//VALUE_RIGHT,
	//VALUE_CENTER,
	VALUE_JUSTIFY,

	// text decoration:
	//VALUE_NONE,
	VALUE_UNDERLINE,
	VALUE_OVERLINE,
	VALUE_LINE_THROUGH,
	VALUE_BLINK,

	// text transform:
	VALUE_CAPITALIZE,
	VALUE_UPPERCASE,
	VALUE_LOWERCASE,
	//VALUE_NONE,

	// white space:
	//VALUE_NORMAL,
	VALUE_PRE,
	VALUE_NOWRAP,
	VALUE_PRE_WRAP,
	VALUE_PRE_LINE,

	// overflow:
	VALUE_VISIBLE,
	//VALUE_HIDDEN,
	//VALUE_SCROLL,
	//VALUE_AUTO,

	// visibility:
	//VALUE_VISIBLE,
	//VALUE_HIDDEN,
	//VALUE_COLLAPSE,

	// gradient sides/corners:
	VALUE_TO_TOP,
	VALUE_TO_RIGHT,
	VALUE_TO_BOTTOM,
	VALUE_TO_LEFT,
	VALUE_TO_TOP_RIGHT,
	VALUE_TO_BOTTOM_RIGHT,
	VALUE_TO_BOTTOM_LEFT,
	VALUE_TO_TOP_LEFT,

	// list style types:
	VALUE_DISC,
	VALUE_CIRCLE,
	VALUE_SQUARE,
	VALUE_DECIMAL,
	VALUE_DECIMAL_LEADING_ZERO,
	VALUE_LOWER_ROMAN,
	VALUE_UPPER_ROMAN,
	VALUE_LOWER_GREEK,
	VALUE_LOWER_LATIN,
	VALUE_UPPER_LATIN,
	VALUE_ARMENIAN,
	VALUE_GEORGIAN,
	VALUE_LOWER_ALPHA,
	VALUE_UPPER_ALPHA,

	// list style positions:
	VALUE_INSIDE,
	VALUE_OUTSIDE,

	// orientation media query:
	VALUE_PORTRAIT,
	VALUE_LANDSCAPE,

	// flex directions:
	VALUE_ROW,
	VALUE_ROW_REVERSE,
	VALUE_COLUMN,
	VALUE_COLUMN_REVERSE,

	// flex wraps:
	//VALUE_NOWRAP,
	VALUE_WRAP,
	VALUE_WRAP_REVERSE,

	// flex basis:
	VALUE_CONTENT,

	// flex justify content:
	VALUE_FLEX_START,
	VALUE_FLEX_END,
	//VALUE_CENTER,
	VALUE_SPACE_BETWEEN,
	VALUE_SPACE_AROUND,

	// flex align items:
	//VALUE_FLEX_START,
	//VALUE_FLEX_END,
	//VALUE_CENTER,
	//VALUE_BASELINE,
	VALUE_STRETCH,

	// cursor:
	//VALUE_AUTO,
	VALUE_DEFAULT,
	VALUE_HELP,
	VALUE_POINTER,
	VALUE_PROGRESS,
	VALUE_WAIT,
	VALUE_TEXT,
	VALUE_MOVE,
	VALUE_NOT_ALLOWED,
	VALUE_ZOOM_IN,
	VALUE_ZOOM_OUT,

	VALUE_MULTIPLE,
	VALUE_GROUP,
	VALUE_SLASH_GROUP,
	VALUE_RECT,
	VALUE_LINEAR_GRADIENT,

	VALUE_COLOR_RGB,
	VALUE_COLOR_RGBA,
	VALUE_COLOR_CURRENT,
	VALUE_URL,
	VALUE_LENGTH,
	VALUE_ANGLE,
	VALUE_OPACITY,
	VALUE_FONT_FAMILY_NAME,
	VALUE_FONT_FAMILY_GENERIC,
	VALUE_FONT_WEIGHT,
	VALUE_NUMBER,
	VALUE_INTEGER,
	VALUE_CONTENT_TEXT,
	VALUE_VARIABLE,
	VALUE_SUBSTITUTION
};

const {
	UNIT_ZERO,
	UNIT_EM,
	UNIT_EX,
	UNIT_CH,
	UNIT_REM,
	UNIT_VW,
	UNIT_VH,
	UNIT_VMIN,
	UNIT_VMAX,
	UNIT_CM,
	UNIT_MM,
	UNIT_Q,
	UNIT_IN,
	UNIT_PC,
	UNIT_PT,
	UNIT_PX,
	UNIT_PERCENT,

	UNIT_DEG,
	UNIT_GRAD,
	UNIT_RAD,
	UNIT_TURN
};

class Value
{
	var type: Integer;

	constructor create(type: Integer)
	{
		this.type = type;
	}

	function to_string(): String
	{
		switch (type) {
			case VALUE_INITIAL:              return "initial";
			case VALUE_INHERIT:              return "inherit";
			case VALUE_UNSET:                return "unset";
			case VALUE_NONE:                 return "none";

			case VALUE_REPEAT:               return "repeat";
			case VALUE_NO_REPEAT:            return "no-repeat";
			case VALUE_SPACE:                return "space";
			case VALUE_ROUND:                return "round";

			case VALUE_FIXED:                return "fixed";
			case VALUE_LOCAL:                return "local";
			case VALUE_SCROLL:               return "scroll";

			case VALUE_LEFT:                 return "left";
			case VALUE_CENTER:               return "center";
			case VALUE_RIGHT:                return "right";
			case VALUE_TOP:                  return "top";
			case VALUE_BOTTOM:               return "bottom";

			case VALUE_BORDER_BOX:           return "border-box";
			case VALUE_PADDING_BOX:          return "padding-box";
			case VALUE_CONTENT_BOX:          return "content-box";

			case VALUE_COVER:                return "cover";
			case VALUE_CONTAIN:              return "contain";
			case VALUE_AUTO:                 return "auto";

			case VALUE_HIDDEN:               return "hidden";
			case VALUE_DOTTED:               return "dotted";
			case VALUE_DASHED:               return "dashed";
			case VALUE_SOLID:                return "solid";
			case VALUE_DOUBLE:               return "double";
			case VALUE_GROOVE:               return "groove";
			case VALUE_RIDGE:                return "ridge";
			case VALUE_INSET:                return "inset";
			case VALUE_OUTSET:               return "outset";

			case VALUE_THIN:                 return "thin";
			case VALUE_MEDIUM:               return "medium";
			case VALUE_THICK:                return "thick";

			case VALUE_COLLAPSE:             return "collapse";
			case VALUE_SEPARATE:             return "separate";

			case VALUE_BOLDER:               return "bolder";
			case VALUE_LIGHTER:              return "lighter";

			case VALUE_NORMAL:               return "normal";
			case VALUE_ITALIC:               return "italic";
			case VALUE_OBLIQUE:              return "oblique";

			case VALUE_XX_SMALL:             return "xx-small";
			case VALUE_X_SMALL:              return "x-small";
			case VALUE_SMALL:                return "small";
			case VALUE_LARGE:                return "large";
			case VALUE_X_LARGE:              return "x-large";
			case VALUE_XX_LARGE:             return "xx-large";
			case VALUE_LARGER:               return "larger";
			case VALUE_SMALLER:              return "smaller";

			case VALUE_INLINE:               return "inline";
			case VALUE_BLOCK:                return "block";
			case VALUE_LIST_ITEM:            return "list-item";
			case VALUE_INLINE_BLOCK:         return "inline-block";
			case VALUE_TABLE:                return "table";
			case VALUE_INLINE_TABLE:         return "inline-table";
			case VALUE_TABLE_ROW_GROUP:      return "table-row-group";
			case VALUE_TABLE_HEADER_GROUP:   return "table-header-group";
			case VALUE_TABLE_FOOTER_GROUP:   return "table-footer-group";
			case VALUE_TABLE_ROW:            return "table-row";
			case VALUE_TABLE_COLUMN_GROUP:   return "table-column-group";
			case VALUE_TABLE_COLUMN:         return "table-column";
			case VALUE_TABLE_CELL:           return "table-cell";
			case VALUE_TABLE_CAPTION:        return "table-caption";
			case VALUE_FLEX:                 return "flex";
			case VALUE_INLINE_FLEX:          return "inline-flex";

			case VALUE_STATIC:               return "static";
			case VALUE_RELATIVE:             return "relative";
			case VALUE_ABSOLUTE:             return "absolute";

			case VALUE_BOTH:                 return "both";

			case VALUE_BASELINE:             return "baseline";
			case VALUE_SUB:                  return "sub";
			case VALUE_SUPER:                return "super";
			case VALUE_TEXT_TOP:             return "text-top";
			case VALUE_MIDDLE:               return "middle";
			case VALUE_TEXT_BOTTOM:          return "text-bottom";

			case VALUE_JUSTIFY:              return "justify";

			case VALUE_UNDERLINE:            return "underline";
			case VALUE_OVERLINE:             return "overline";
			case VALUE_LINE_THROUGH:         return "line-through";
			case VALUE_BLINK:                return "blink";

			case VALUE_CAPITALIZE:           return "capitalize";
			case VALUE_UPPERCASE:            return "uppercase";
			case VALUE_LOWERCASE:            return "lowercase";

			case VALUE_PRE:                  return "pre";
			case VALUE_NOWRAP:               return "nowrap";
			case VALUE_PRE_WRAP:             return "pre-wrap";
			case VALUE_PRE_LINE:             return "pre-line";

			case VALUE_VISIBLE:              return "visible";

			case VALUE_TO_TOP:               return "to top";
			case VALUE_TO_RIGHT:             return "to right";
			case VALUE_TO_BOTTOM:            return "to bottom";
			case VALUE_TO_LEFT:              return "to left";
			case VALUE_TO_TOP_RIGHT:         return "to top right";
			case VALUE_TO_BOTTOM_RIGHT:      return "to bottom right";
			case VALUE_TO_BOTTOM_LEFT:       return "to bottom left";
			case VALUE_TO_TOP_LEFT:          return "to top left";

			case VALUE_DISC:                 return "disc";
			case VALUE_CIRCLE:               return "circle";
			case VALUE_SQUARE:               return "square";
			case VALUE_DECIMAL:              return "decimal";
			case VALUE_DECIMAL_LEADING_ZERO: return "decimal-leading-zero";
			case VALUE_LOWER_ROMAN:          return "lower-roman";
			case VALUE_UPPER_ROMAN:          return "upper-roman";
			case VALUE_LOWER_GREEK:          return "lower-greek";
			case VALUE_LOWER_LATIN:          return "lower-latin";
			case VALUE_UPPER_LATIN:          return "upper-latin";
			case VALUE_ARMENIAN:             return "armenian";
			case VALUE_GEORGIAN:             return "georgian";
			case VALUE_LOWER_ALPHA:          return "lower-alpha";
			case VALUE_UPPER_ALPHA:          return "upper-alpha";

			case VALUE_INSIDE:               return "inside";
			case VALUE_OUTSIDE:              return "outside";

			case VALUE_PORTRAIT:             return "portrait";
			case VALUE_LANDSCAPE:            return "landscape";

			case VALUE_ROW:                  return "row";
			case VALUE_ROW_REVERSE:          return "row-reverse";
			case VALUE_COLUMN:               return "column";
			case VALUE_COLUMN_REVERSE:       return "column-reverse";

			case VALUE_WRAP:                 return "wrap";
			case VALUE_WRAP_REVERSE:         return "wrap-reverse";

			case VALUE_CONTENT:              return "content";

			case VALUE_FLEX_START:           return "flex-start";
			case VALUE_FLEX_END:             return "flex-end";
			case VALUE_SPACE_BETWEEN:        return "space-between";
			case VALUE_SPACE_AROUND:         return "space-around";

			case VALUE_STRETCH:              return "stretch";

			case VALUE_DEFAULT:              return "default";
			case VALUE_HELP:                 return "help";
			case VALUE_POINTER:              return "pointer";
			case VALUE_PROGRESS:             return "progress";
			case VALUE_WAIT:                 return "wait";
			case VALUE_TEXT:                 return "text";
			case VALUE_MOVE:                 return "move";
			case VALUE_NOT_ALLOWED:          return "not-allowed";
			case VALUE_ZOOM_IN:              return "zoom-in";
			case VALUE_ZOOM_OUT:             return "zoom-out";

			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
			case VALUE_LINEAR_GRADIENT:
				return (this as ListValue).to_string();

			case VALUE_RECT:
				return (this as RectValue).to_string();

			case VALUE_COLOR_RGB:
			case VALUE_COLOR_RGBA:
			case VALUE_COLOR_CURRENT:
				return (this as ColorValue).to_string();

			case VALUE_URL:
				return (this as URLValue).to_string();

			case VALUE_LENGTH:
			case VALUE_ANGLE:
				return (this as MeasurementValue).to_string();

			case VALUE_OPACITY:
				return (this as OpacityValue).to_string();

			case VALUE_FONT_FAMILY_NAME:
			case VALUE_FONT_FAMILY_GENERIC:
				return (this as FontFamilyValue).to_string();

			case VALUE_FONT_WEIGHT:
				return (this as FontWeightValue).to_string();

			case VALUE_NUMBER:
				return (this as NumberValue).to_string();

			case VALUE_INTEGER:
				return (this as IntegerValue).to_string();

			case VALUE_CONTENT_TEXT:
				return (this as ContentTextValue).to_string();

			case VALUE_VARIABLE:
				return (this as VariableValue).to_string();

			case VALUE_SUBSTITUTION:
				return (this as SubstitutionValue).to_string();
		}

		throw error("unknown value type");
	}
}

class ListValue: Value
{
	constructor create(type: Integer)
	{
		super::create(type);
	}

	static function is_instance(value: Value): Boolean
	{
		switch (value.type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
			case VALUE_LINEAR_GRADIENT:
				return true;
		}
		return false;
	}

	function add_child(child: Value)
	{
		switch (type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
			case VALUE_LINEAR_GRADIENT:
				(this as Dynamic[])[] = child;
				return;
		}
		throw error("not multiple or group");
	}

	function remove_child(idx: Integer)
	{
		if (idx < 0) throw error("invalid index");
		switch (type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
				(this as Dynamic[]).remove(ListValue::SIZE+idx);
				return;

			case VALUE_LINEAR_GRADIENT:
				(this as Dynamic[]).remove(LinearGradientValue::SIZE+idx);
				return;
		}
		throw error("not multiple or group");
	}

	function insert_child(idx: Integer, child: Value)
	{
		if (idx < 0) throw error("invalid index");
		switch (type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
				(this as Dynamic[]).insert(ListValue::SIZE+idx, child);
				return;

			case VALUE_LINEAR_GRADIENT:
				(this as Dynamic[]).insert(LinearGradientValue::SIZE+idx, child);
				return;
		}
		throw error("not multiple or group");
	}

	function get_child_count(): Integer
	{
		switch (type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
				return (this as Dynamic[]).length-ListValue::SIZE;

			case VALUE_LINEAR_GRADIENT:
				return (this as Dynamic[]).length-LinearGradientValue::SIZE;
		}
		throw error("not multiple or group");
	}

	function get_child(idx: Integer): Value
	{
		if (idx < 0) throw error("invalid index");
		switch (type) {
			case VALUE_MULTIPLE:
			case VALUE_GROUP:
			case VALUE_SLASH_GROUP:
				return (this as Dynamic[])[ListValue::SIZE+idx];

			case VALUE_LINEAR_GRADIENT:
				return (this as Dynamic[])[LinearGradientValue::SIZE+idx];
		}
		throw error("not multiple or group");
	}

	function to_string(): String
	{
		var s = {""}, delim: String;
		switch (type) {
			default:
			case VALUE_MULTIPLE: delim = ", "; break;
			case VALUE_GROUP: delim = " "; break;
			case VALUE_SLASH_GROUP: delim = " / "; break;
			case VALUE_LINEAR_GRADIENT: delim = ", "; break;
		}
		for (var i=0, n=get_child_count(); i<n; i++) {
			if (s.length > 0) s += delim;
			s += get_child(i).to_string();
		}
		switch (type) {
			case VALUE_LINEAR_GRADIENT: s = "linear-gradient("+s+")"; break;
		}
		return s;
	}
}

class MultipleValue: ListValue
{
	constructor create()
	{
		super::create(VALUE_MULTIPLE);
	}
}

class GroupValue: ListValue
{
	constructor create()
	{
		super::create(VALUE_GROUP);
	}

	constructor create(v1: Value, v2: Value)
	{
		super::create(VALUE_GROUP);
		add_child(v1);
		add_child(v2);
	}
}

class SlashGroupValue: GroupValue
{
	constructor create(v1: Value, v2: Value)
	{
		super::create();
		this.type = VALUE_SLASH_GROUP;
		add_child(v1);
		add_child(v2);
	}
}

class RectValue: Value
{
	var top: Value;
	var right: Value;
	var bottom: Value;
	var left: Value;

	constructor create(top: Value, right: Value, bottom: Value, left: Value)
	{
		super::create(VALUE_RECT);
		this.top = top;
		this.right = right;
		this.bottom = bottom;
		this.left = left;
	}

	function to_string(): String
	{
		return "rect("+top.to_string()+", "+right.to_string()+", "+bottom.to_string()+", "+left.to_string()+")";
	}
}

class LinearGradientValue: ListValue
{
	var angle: Value;

	constructor create(angle: Value)
	{
		super::create(VALUE_LINEAR_GRADIENT);
		this.angle = angle;
	}
}

class ColorValue: Value
{
	var color: Integer;

	constructor create_rgb(color: Integer)
	{
		super::create(VALUE_COLOR_RGB);
		this.color = color;
	}

	constructor create_rgba(color: Integer)
	{
		super::create(VALUE_COLOR_RGBA);
		this.color = color;
	}

	static function create_current(): Value
	{
		return Value::create(VALUE_COLOR_CURRENT);
	}

	static function is_instance(value: Value): Boolean
	{
		switch (value.type) {
			case VALUE_COLOR_RGB:
			case VALUE_COLOR_RGBA:
			case VALUE_COLOR_CURRENT:
				return true;
		}
		return false;
	}

	function to_string(): String
	{
		switch (type) {
			case VALUE_COLOR_RGB:
				return "#"+String::from_hex_int(color).pad_left(6, '0');

			case VALUE_COLOR_RGBA: {
				var argb = color;
				var a = (argb >> 24) & 0xFF;
				var r = (argb >> 16) & 0xFF;
				var g = (argb >>  8) & 0xFF;
				var b = (argb >>  0) & 0xFF;
				return "rgba("+r+", "+g+", "+b+", "+(a / 255.0)+")";
			}

			case VALUE_COLOR_CURRENT:
				return "currentColor";
		}
		throw error("invalid color value");
	}
}

class URLValue: Value
{
	var url: String;

	constructor create(url: String)
	{
		super::create(VALUE_URL);
		this.url = url;
	}

	function to_string(): String
	{
		return "url("+css_serialize_string(url)+")";
	}
}

class MeasurementValue: Value
{
	var value: Float;
	var unit: Integer;

	constructor create(type: Integer, value: Float, unit: Integer)
	{
		super::create(type);
		this.value = value;
		this.unit = unit;
	}

	function to_string(): String
	{
		var s = {value};
		if (s.length > 2 && s[s.length-2] == '.' && s[s.length-1] == '0') {
			s.set_length(s.length-2);
		}
		s += unit_to_string(unit);
		return s;
	}
}

class LengthValue: MeasurementValue
{
	constructor create(value: Float, unit: Integer)
	{
		super::create(VALUE_LENGTH, value, unit);
	}

	function to_pixels(screen_width: Integer, screen_height: Integer): Integer
	{
		var font_size = 16.0;

		switch (unit) {
			case UNIT_ZERO: return 0;
			case UNIT_EM:   return iround(value * font_size);
			case UNIT_EX:   return iround(value * font_size * 0.625);
			case UNIT_CH:   return iround(value * font_size * 0.5);
			case UNIT_REM:  return iround(value * font_size);
			case UNIT_VW:   return iround(value / 100.0 * screen_width);
			case UNIT_VH:   return iround(value / 100.0 * screen_height);
			case UNIT_VMIN: return iround(value / 100.0 * min(screen_width, screen_height));
			case UNIT_VMAX: return iround(value / 100.0 * max(screen_width, screen_height));
			case UNIT_CM:   return iround(value * 96.0 / 2.54);
			case UNIT_MM:   return iround(value * 96.0 / 2.54 / 10.0);
			case UNIT_Q:    return iround(value * 96.0 / 2.54 / 40.0);
			case UNIT_IN:   return iround(value * 96.0);
			case UNIT_PC:   return iround(value * 96.0 / 6.0);
			case UNIT_PT:   return iround(value * 96.0 / 72.0);
			case UNIT_PX:   return iround(value);
		}
		throw error("unsupported length unit");
	}
}

class AngleValue: MeasurementValue
{
	constructor create(value: Float, unit: Integer)
	{
		super::create(VALUE_ANGLE, value, unit);
	}
}

class OpacityValue: Value
{
	var opacity: Float;

	constructor create(opacity: Float)
	{
		super::create(VALUE_OPACITY);
		this.opacity = opacity;
	}

	function to_string(): String
	{
		return {opacity};
	}
}

class FontFamilyValue: Value
{
	var name: String;

	constructor create(name: String)
	{
		super::create(VALUE_FONT_FAMILY_NAME);
		this.name = name;
	}

	constructor create_generic(name: String)
	{
		super::create(VALUE_FONT_FAMILY_GENERIC);
		this.name = name;
	}

	function to_string(): String
	{
		switch (type) {
			case VALUE_FONT_FAMILY_NAME:
				return css_serialize_string(name);

			case VALUE_FONT_FAMILY_GENERIC:
				return name;
		}
		throw error("invalid font family value");
	}
}

class FontWeightValue: Value
{
	var weight: Integer;

	constructor create(weight: Integer)
	{
		super::create(VALUE_FONT_WEIGHT);
		this.weight = weight;
	}

	function to_string(): String
	{
		return {weight};
	}
}

class NumberValue: Value
{
	var value: Float;

	constructor create(value: Float)
	{
		super::create(VALUE_NUMBER);
		this.value = value;
	}

	function to_string(): String
	{
		return {value};
	}
}

class IntegerValue: Value
{
	var value: Integer;

	constructor create(value: Integer)
	{
		super::create(VALUE_INTEGER);
		this.value = value;
	}

	function to_string(): String
	{
		return {value};
	}
}

class ContentTextValue: Value
{
	var text: String;

	constructor create(text: String)
	{
		super::create(VALUE_CONTENT_TEXT);
		this.text = text;
	}

	function to_string(): String
	{
		return css_serialize_string(text);
	}
}

class VariableValue: Value
{
	var tokens: Parser;

	constructor create(tokens: Parser)
	{
		super::create(VALUE_VARIABLE);
		this.tokens = tokens;
	}

	function to_string(): String
	{
		return serialize_css_tokens(tokens);
	}
}

class SubstitutionValue: Value
{
	var tokens: Parser;

	constructor create(tokens: Parser)
	{
		super::create(VALUE_SUBSTITUTION);
		this.tokens = tokens;
	}

	function to_string(): String
	{
		return serialize_css_tokens(tokens);
	}
}

function @unit_to_string(unit: Integer): String
{
	switch (unit) {
		case UNIT_ZERO:    return "";
		case UNIT_EM:      return "em";
		case UNIT_EX:      return "ex";
		case UNIT_CH:      return "ch";
		case UNIT_REM:     return "rem";
		case UNIT_VW:      return "vw";
		case UNIT_VH:      return "vh";
		case UNIT_VMIN:    return "vmin";
		case UNIT_VMAX:    return "vmax";
		case UNIT_CM:      return "cm";
		case UNIT_MM:      return "mm";
		case UNIT_Q:       return "Q";
		case UNIT_IN:      return "in";
		case UNIT_PC:      return "pc";
		case UNIT_PT:      return "pt";
		case UNIT_PX:      return "px";
		case UNIT_PERCENT: return "%";

		case UNIT_DEG:     return "deg";
		case UNIT_GRAD:    return "grad";
		case UNIT_RAD:     return "rad";
		case UNIT_TURN:    return "turn";
	}

	throw error("unknown unit type");
}
