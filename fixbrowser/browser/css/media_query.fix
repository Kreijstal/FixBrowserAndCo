/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "string_switch";
use "classes";

import "browser/css/parser";
import "browser/css/property";
import "browser/css/value";
import "util/string";

const {
	MEDIA_WIDTH,
	MEDIA_HEIGHT,
	MEDIA_DEVICE_WIDTH,
	MEDIA_DEVICE_HEIGHT,
	MEDIA_ORIENTATION,
	MEDIA_ASPECT_RATIO,
	MEDIA_DEVICE_ASPECT_RATIO,

	MEDIA_ALL,
	MEDIA_SCREEN,

	MEDIA_ONLY,
	MEDIA_NOT,
	MEDIA_AND,
	MEDIA_OR
};

const {
	CMP_EXISTS,
	CMP_EXACT,
	CMP_MIN,
	CMP_MAX
};

// TODO: make it better
class MediaQuery
{
	var type: Integer;
	
	// values:
	var cmp: Integer;
	var value: Value;

	// logical:
	var first: MediaQuery;
	var second: MediaQuery;

	constructor create(type: Integer)
	{
		this.type = type;
	}

	constructor create_values(type: Integer, cmp: Integer, value: Value)
	{
		this.type = type;
		this.cmp = cmp;
		this.value = value;
	}

	constructor create_logical(type: Integer, first: MediaQuery)
	{
		this.type = type;
		this.first = first;
	}

	constructor create_logical(type: Integer, first: MediaQuery, second: MediaQuery)
	{
		this.type = type;
		this.first = first;
		this.second = second;
	}
}

const @UNKNOWN_FEATURE = -1;

function @consume_whitespace(par: Parser)
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	back_token(par);
}

function parse_media_query_list(par: Parser): MediaQuery
{
	var media: MediaQuery;
	
	for (;;) {
		consume_whitespace(par);
		var token = next_token(par);
		if (token != TOKEN_IDENT && token != COMPONENT_SIMPLE_BLOCK) break;

		back_token(par);
		var media2 = parse_media_query(par);
		media = media? MediaQuery::create_logical(MEDIA_OR, media, media2) : media2;

		if (next_token(par) != TOKEN_COMMA) break;
	}
	
	return media;
}

function @flush(par: Parser)
{
	for (;;) {
		var token = next_token(par);
		if (token == TOKEN_EOF || token == TOKEN_COMMA) break;
	}
	back_token(par);
}

function @expect_ident_or_flush(par: Parser): Boolean
{
	if (next_token(par) != TOKEN_IDENT) {
		back_token(par);
		flush(par);
		return false;
	}
	return true;
}

function @parse_media_query(par: Parser): MediaQuery
{
	if (next_token(par) == COMPONENT_SIMPLE_BLOCK && (par.value as SimpleBlock).associated_token == TOKEN_LBRACKET) {
		back_token(par);
		var media = parse_expression(par);
		if (!media) return null;
		
		if (media == UNKNOWN_FEATURE) {
			return MediaQuery::create_logical(MEDIA_NOT, MediaQuery::create(MEDIA_ALL));
		}

		for (;;) {
			if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "and") {
				consume_whitespace(par);
				var expr = parse_expression(par);
				if (!expr) return null;
				if (expr == UNKNOWN_FEATURE) {
					return MediaQuery::create_logical(MEDIA_NOT, MediaQuery::create(MEDIA_ALL));
				}
				media = MediaQuery::create_logical(MEDIA_AND, media, expr);
			}
			else {
				back_token(par);
				break;
			}
		}
		return media;
	}
	else {
		back_token(par);
	}

	if (!expect_ident_or_flush(par)) return null;

	var use_only = false, use_not = false;

	var name = (par.value as String).to_lower_case();
	if (name == "only") {
		use_only = true;
		consume_whitespace(par);
		if (!expect_ident_or_flush(par)) return null;
		name = (par.value as String).to_lower_case();
	}
	else if (name == "not") {
		use_not = true;
		consume_whitespace(par);
		if (!expect_ident_or_flush(par)) return null;
		name = (par.value as String).to_lower_case();
	}

	var type = -1;
	switch (name) {
		case "all":    type = MEDIA_ALL; break;
		case "screen": type = MEDIA_SCREEN; break;
	}

	if (type == -1) {
		type = MEDIA_ALL;
		use_not = !use_not;
		use_only = false;
	}

	var media = MediaQuery::create(type);

	consume_whitespace(par);
	
	for (;;) {
		if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "and") {
			consume_whitespace(par);
			var expr = parse_expression(par);
			if (!expr) return null;
			if (expr == UNKNOWN_FEATURE) {
				return MediaQuery::create_logical(MEDIA_NOT, MediaQuery::create(MEDIA_ALL));
			}
			media = MediaQuery::create_logical(MEDIA_AND, media, expr);
		}
		else {
			back_token(par);
			break;
		}
	}

	if (use_only) {
		media = MediaQuery::create_logical(MEDIA_ONLY, media);
	}
	if (use_not) {
		media = MediaQuery::create_logical(MEDIA_NOT, media);
	}
	return media;
}

function @parse_expression(par: Parser): Dynamic
{
	if (next_token(par) != COMPONENT_SIMPLE_BLOCK) {
		flush(par);
		return null;
	}

	var block = par.value as SimpleBlock;
	if (block.associated_token != TOKEN_LBRACKET) {
		flush(par);
		return null;
	}

	rewind_buffer(block);
	consume_whitespace(block);
	
	if (next_token(block) != TOKEN_IDENT) {
		flush(par);
		return null;
	}
	var name = (block.value as String).to_lower_case();

	var type = -1, cmp = CMP_EXISTS, value: Value;

	if (name.starts_with("min-")) {
		cmp = CMP_MIN;
		name.remove(0, 4);
	}
	else if (name.starts_with("max-")) {
		cmp = CMP_MAX;
		name.remove(0, 4);
	}
	
	switch (name) {
		case "width":               type = MEDIA_WIDTH; break;
		case "height":              type = MEDIA_HEIGHT; break;
		case "device-width":        type = MEDIA_DEVICE_WIDTH; break;
		case "device-height":       type = MEDIA_DEVICE_HEIGHT; break;
		case "orientation":         type = MEDIA_ORIENTATION; break;
		case "aspect-ratio":        type = MEDIA_ASPECT_RATIO; break;
		case "device-aspect-ratio": type = MEDIA_DEVICE_ASPECT_RATIO; break;
	}

	if (type == -1) {
		consume_whitespace(par);
		return UNKNOWN_FEATURE;
	}

	consume_whitespace(block);
	if (next_token(block) == TOKEN_COLON) {
		if (cmp == CMP_EXISTS) {
			cmp = CMP_EXACT;
		}
		consume_whitespace(block);

		switch (type) {
			case MEDIA_WIDTH:
			case MEDIA_HEIGHT:
			case MEDIA_DEVICE_WIDTH:
			case MEDIA_DEVICE_HEIGHT: {
				var (len, e) = parse_length(block);
				if (e) {
					flush(par);
					return null;
				}
				if (len.value < 0.0) {
					flush(par);
					return null;
				}
				value = len;
				break;
			}
				
			case MEDIA_ORIENTATION: {
				if (cmp == CMP_MIN || cmp == CMP_MAX) {
					flush(par);
					return null;
				}
				if (next_token(block) != TOKEN_IDENT) {
					flush(par);
					return null;
				}
				var orient = (block.value as String).to_lower_case();
				if (orient == "portrait") {
					value = Value::create(VALUE_PORTRAIT);
				}
				else if (orient == "landscape") {
					value = Value::create(VALUE_LANDSCAPE);
				}
				else {
					flush(par);
					return null;
				}
				break;
			}
				
			case MEDIA_ASPECT_RATIO:
			case MEDIA_DEVICE_ASPECT_RATIO: {
				if (next_token(block) != TOKEN_NUMBER) {
					flush(par);
					return null;
				}
				var v1 = block.value as Number;
				consume_whitespace(block);
				if (next_token(block) != TOKEN_DELIM || (block.value as Integer) != '/') {
					flush(par);
					return null;
				}
				consume_whitespace(block);
				if (next_token(block) != TOKEN_NUMBER) {
					flush(par);
					return null;
				}
				var v2 = block.value as Number;
				if (v1.is_number || v2.is_number || (v1.value as Integer) < 1 || (v2.value as Integer) < 1) {
					flush(par);
					return null;
				}
				value = SlashGroupValue::create(IntegerValue::create(v1.value as Integer), IntegerValue::create(v2.value as Integer));
				break;
			}

			default: throw error("unhandled case");
		}
	}
	else {
		back_token(block);

		if (cmp == CMP_MIN || cmp == CMP_MAX) {
			flush(par);
			return null;
		}
	}
	
	consume_whitespace(block);
	if (next_token(block) != TOKEN_EOF) {
		flush(par);
		return null;
	}

	consume_whitespace(par);
	return MediaQuery::create_values(type, cmp, value);
}

function serialize_media_query(media: MediaQuery): String
{
	switch (media.type) {
		case MEDIA_ALL:    return "all";
		case MEDIA_SCREEN: return "screen";

		case MEDIA_ONLY:
			return "only "+serialize_media_query(media.first);

		case MEDIA_NOT:
			return "not "+serialize_media_query(media.first);

		case MEDIA_AND:
			return serialize_media_query(media.first)+" and "+serialize_media_query(media.second);

		case MEDIA_OR:
			return serialize_media_query(media.first)+", "+serialize_media_query(media.second);
	}

	var s = {"("};
	switch (media.cmp) {
		case CMP_EXISTS, CMP_EXACT: break;
		case CMP_MIN: s += "min-"; break;
		case CMP_MAX: s += "max-"; break;
		default: throw error("unknown compare type");
	}
	switch (media.type) {
		case MEDIA_WIDTH:               s += "width"; break;
		case MEDIA_HEIGHT:              s += "height"; break;
		case MEDIA_DEVICE_WIDTH:        s += "device-width"; break;
		case MEDIA_DEVICE_HEIGHT:       s += "device-height"; break;
		case MEDIA_ORIENTATION:         s += "orientation"; break;
		case MEDIA_ASPECT_RATIO:        s += "aspect-ratio"; break;
		case MEDIA_DEVICE_ASPECT_RATIO: s += "device-aspect-ratio"; break;
		default: throw error("unknown media type");
	}
	if (media.cmp != CMP_EXISTS) {
		s[] = ':';
		s[] = ' ';
		s += media.value.to_string();
	}
	s[] = ')';
	return s;
}
