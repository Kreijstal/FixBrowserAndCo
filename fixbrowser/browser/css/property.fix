/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "util/time_literals";
use "string_switch";
use "classes";

import "browser/css/parser";
import "browser/css/value";
import "util/string";
import "util/memory_cache";

const {
	PROP_ALL,

	PROP_COLOR,

	PROP_BACKGROUND_COLOR,
	PROP_BACKGROUND_IMAGE,
	PROP_BACKGROUND_REPEAT,
	PROP_BACKGROUND_ATTACHMENT,
	PROP_BACKGROUND_POSITION,
	PROP_BACKGROUND_CLIP,
	PROP_BACKGROUND_ORIGIN,
	PROP_BACKGROUND_SIZE,
	PROP_BACKGROUND,

	PROP_BORDER_TOP_COLOR,
	PROP_BORDER_RIGHT_COLOR,
	PROP_BORDER_BOTTOM_COLOR,
	PROP_BORDER_LEFT_COLOR,
	PROP_BORDER_COLOR,

	PROP_BORDER_TOP_STYLE,
	PROP_BORDER_RIGHT_STYLE,
	PROP_BORDER_BOTTOM_STYLE,
	PROP_BORDER_LEFT_STYLE,
	PROP_BORDER_STYLE,

	PROP_BORDER_TOP_WIDTH,
	PROP_BORDER_RIGHT_WIDTH,
	PROP_BORDER_BOTTOM_WIDTH,
	PROP_BORDER_LEFT_WIDTH,
	PROP_BORDER_WIDTH,

	PROP_BORDER_TOP,
	PROP_BORDER_RIGHT,
	PROP_BORDER_BOTTOM,
	PROP_BORDER_LEFT,
	PROP_BORDER,

	PROP_BORDER_TOP_LEFT_RADIUS,
	PROP_BORDER_TOP_RIGHT_RADIUS,
	PROP_BORDER_BOTTOM_RIGHT_RADIUS,
	PROP_BORDER_BOTTOM_LEFT_RADIUS,
	PROP_BORDER_RADIUS,

	PROP_BORDER_COLLAPSE,
	PROP_BORDER_SPACING,

	PROP_BOX_SHADOW,
	PROP_TEXT_SHADOW,
	PROP_OPACITY,

	PROP_FONT_FAMILY,
	PROP_FONT_WEIGHT,
	PROP_FONT_STYLE,
	PROP_FONT_SIZE,
	PROP_FONT,

	PROP_LINE_HEIGHT,

	PROP_MARGIN_TOP,
	PROP_MARGIN_RIGHT,
	PROP_MARGIN_BOTTOM,
	PROP_MARGIN_LEFT,
	PROP_MARGIN,

	PROP_PADDING_TOP,
	PROP_PADDING_RIGHT,
	PROP_PADDING_BOTTOM,
	PROP_PADDING_LEFT,
	PROP_PADDING,

	PROP_DISPLAY,
	PROP_POSITION,
	PROP_TOP,
	PROP_RIGHT,
	PROP_BOTTOM,
	PROP_LEFT,
	PROP_FLOAT,
	PROP_CLEAR,
	PROP_Z_INDEX,

	PROP_WIDTH,
	PROP_HEIGHT,
	PROP_MIN_WIDTH,
	PROP_MAX_WIDTH,
	PROP_MIN_HEIGHT,
	PROP_MAX_HEIGHT,
	PROP_VERTICAL_ALIGN,
	PROP_BOX_SIZING,

	PROP_TEXT_ALIGN,
	PROP_TEXT_INDENT,
	PROP_TEXT_DECORATION,
	PROP_LETTER_SPACING,
	PROP_WORD_SPACING,
	PROP_TEXT_TRANSFORM,
	PROP_WHITE_SPACE,

	PROP_OVERFLOW,
	PROP_OVERFLOW_X,
	PROP_OVERFLOW_Y,
	PROP_CLIP,
	PROP_VISIBILITY,

	PROP_LIST_STYLE_TYPE,
	PROP_LIST_STYLE_IMAGE,
	PROP_LIST_STYLE_POSITION,
	PROP_LIST_STYLE,

	PROP_CONTENT,

	PROP_FLEX_DIRECTION,
	PROP_FLEX_WRAP,
	PROP_FLEX_FLOW,
	PROP_ORDER,
	PROP_FLEX_GROW,
	PROP_FLEX_SHRINK,
	PROP_FLEX_BASIS,
	PROP_FLEX,
	PROP_JUSTIFY_CONTENT,
	PROP_ALIGN_ITEMS,
	PROP_ALIGN_SELF,
	PROP_ALIGN_CONTENT,

	PROP_TAB_SIZE,

	PROP_CURSOR
};

class Property
{
	var type: Integer;
	var name: String;
	var value: Value;
	var important: Boolean;

	constructor create(type: Integer, name: String, value: Value, important: Boolean)
	{
		this.type = type;
		this.name = name;
		this.value = value;
		this.important = important;
	}

	function to_string(): String
	{
		var s = name+": "+value.to_string();
		if (important) {
			s += " !important";
		}
		s[] = ';';
		return s;
	}
}

struct @PropertyData
{
	var name: String;
	var type: Integer;
	var handler;
	var multiple: Boolean;
}

var @property_hash: PropertyData[String];
var @property_data: [PropertyData];
var @colors: Integer[String];

function is_property_inherited(type: Integer): Boolean
{
	switch (type) {
		case PROP_COLOR:

		case PROP_BORDER_COLLAPSE:
		case PROP_BORDER_SPACING:

		case PROP_TEXT_SHADOW:

		case PROP_FONT_FAMILY:
		case PROP_FONT_WEIGHT:
		case PROP_FONT_STYLE:
		case PROP_FONT_SIZE:
		case PROP_FONT:

		case PROP_LINE_HEIGHT:

		case PROP_TEXT_ALIGN:
		case PROP_TEXT_INDENT:
		case PROP_LETTER_SPACING:
		case PROP_WORD_SPACING:
		case PROP_TEXT_TRANSFORM:
		case PROP_WHITE_SPACE:

		case PROP_VISIBILITY:

		case PROP_LIST_STYLE_TYPE:
		case PROP_LIST_STYLE_IMAGE:
		case PROP_LIST_STYLE_POSITION:
		case PROP_LIST_STYLE:

		case PROP_TAB_SIZE:

		case PROP_CURSOR:
			return true;
	}
	return false;
}

function parse_properties(par: Parser): Property[]
{
	if (!property_hash) {
		init_static_data();
	}

	var properties: Property[] = [];
	var unknown_props: Boolean[String], new_unknown_props: Boolean[String];
	
	rewind_buffer(par);
	while (next_token(par) != TOKEN_EOF) {
		if (par.type != COMPONENT_DECLARATION) continue;
		var decl = par.value as Declaration;
		var name = decl.name.to_lower_case();
		var important = decl.important;
		//log("  name="+name+" important="+important);
		var idx = property_hash.get(name, null);
		if ((idx as Dynamic) != null) { //XXX
			if (css_tokens_has_variables(decl)) {
				trim_css_tokens(decl);
				properties[] = Property::create(VALUE_SUBSTITUTION, name, SubstitutionValue::create(decl), false);
			}
			else {
				rewind_buffer(decl);
				consume_whitespace(decl);
				name = property_data[idx].name;
				var type = property_data[idx].type;
				var handler = property_data[idx].handler;
				var multiple = property_data[idx].multiple;
				var (prop, e) = parse_property(type, name, handler, multiple, important, decl);
				//if (e) dump(e);
				if (prop != null && !e) { //XXX
					consume_whitespace(decl);
					if (next_token(decl) == TOKEN_EOF) {
						properties[] = prop;
						//log("  "+prop.to_string());
					}
				}
			}
		}
		else if (name.length > 2 && name.starts_with("--")) {
			trim_css_tokens(decl);
			var value = VariableValue::create(decl);
			var found = false;
			foreach (var prop in properties) {
				if (prop.name == name) {
					prop.value = value;
					found = true;
					break;
				}
			}
			if (!found) {
				properties[] = Property::create(VALUE_VARIABLE, name, value, false);
			}
		}
		else {
			if (!unknown_props) {
				unknown_props = MemoryCache::get("unknown_css_properties");
				if (!unknown_props) {
					unknown_props = {};
				}
				new_unknown_props = {};
			}
			if (!unknown_props.contains(name) && !new_unknown_props.contains(name)) {
				log("unhandled CSS property: "+name);
				new_unknown_props[name] = true;
			}
		}
	}

	if (new_unknown_props != null && new_unknown_props.length > 0) { //XXX
		var props = MemoryCache::get("unknown_css_properties") as Boolean[String];
		for (;;) {
			var new_props = props? clone(props) : {} as Boolean[String];
			foreach (var k, v in new_unknown_props) {
				new_props[k] = v;
			}
			var old_props = MemoryCache::cond_swap("unknown_css_properties", props, new_props, 1 hour);
			if (old_props == props) break;
			props = old_props;
		}
	}

	return properties;
}

function @parse_property(type: Integer, name: String, handler, multiple: Boolean, important: Boolean, par: Parser): Property
{
	var value;

	if (next_token(par) == TOKEN_IDENT) {
		var ident_name = par.value as String;
		switch (ident_name.to_lower_case()) {
			case "initial": value = Value::create(VALUE_INITIAL); break;
			case "inherit": value = Value::create(VALUE_INHERIT); break;
			case "unset":   value = Value::create(VALUE_UNSET); break;
		}
	}

	if (!value) {
		back_token(par);
		value = multiple? parse_multiple(par, handler) : handler(par);
		if (!value) {
			throw error("empty value");
		}
	}
	
	return Property::create(type, name, value, important);
}

function @consume_whitespace(par: Parser)
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	back_token(par);
}

function @next_is_integer(par: Parser): Boolean
{
	consume_whitespace(par);
	var token = next_token(par);
	back_token(par);
	return (token == TOKEN_NUMBER);
}

function @consume_integer(par: Parser): Integer
{
	consume_whitespace(par);
	if (next_token(par) != TOKEN_NUMBER) {
		throw error("not an integer");
	}
	var value = par.value as Number;
	if (value.is_number) {
		throw error("not an integer");
	}
	return value.value as Integer;
}

function @consume_float(par: Parser): Float
{
	consume_whitespace(par);
	if (next_token(par) != TOKEN_NUMBER) {
		throw error("not float");
	}
	return (par.value as Number).as_float();
}

function @consume_percentage(par: Parser): Float
{
	consume_whitespace(par);
	if (next_token(par) != TOKEN_PERCENTAGE) {
		throw error("not percentage");
	}
	return (par.value as Number).as_float();
}

function @consume_comma(par: Parser)
{
	consume_whitespace(par);
	if (next_token(par) != TOKEN_COMMA) {
		throw error("not a comma");
	}
}

function @consume_eof(par: Parser)
{
	consume_whitespace(par);
	if (next_token(par) != TOKEN_EOF) {
		throw error("not EOF");
	}
}

function @expect_ident(par: Parser): String
{
	if (next_token(par) != TOKEN_IDENT) {
		throw error("expected ident");
	}
	return (par.value as String).to_lower_case();
}

function @parse_all(par: Parser)
{
	throw error("invalid value");
}

function @hsl_to_rgb(h: Float, s: Float, l: Float): Integer
{
	var m2: Float;
	if (l < 0.5) {
		m2 = l * (s + 1.0);
	}
	else {
		m2 = l + s - l * s;
	}
	var m1 = l * 2.0 - m2;
	var fr = hue_to_rgb(m1, m2, h + 1.0 / 3.0);
	var fg = hue_to_rgb(m1, m2, h);
	var fb = hue_to_rgb(m1, m2, h - 1.0 / 3.0);
	var r = iround(fr * 255.0);
	var g = iround(fg * 255.0);
	var b = iround(fb * 255.0);
	r = clamp(r, 0, 255);
	g = clamp(g, 0, 255);
	b = clamp(b, 0, 255);
	return (r<<16)|(g<<8)|b;
}

function @hue_to_rgb(m1: Float, m2: Float, h: Float): Float
{
	if (h < 0.0) h = h + 1.0;
	if (h > 1.0) h = h - 1.0;
	if (h * 6.0 < 1.0) return m1 + ((m2 - m1) * h * 6.0);
	if (h * 2.0 < 1.0) return m2;
	if (h * 3.0 < 2.0) return m1 + ((m2 - m1) * (2.0 / 3.0 - h) * 6.0);
	return m1;
}

function @parse_color(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		var color = colors.get(name, -1);
		if (color != -1) {
			return ColorValue::create_rgb(color);
		}
		if (name == "transparent") {
			return ColorValue::create_rgba(0x00000000);
		}
		if (name == "currentcolor") {
			return ColorValue::create_current();
		}
	}
	if (token == TOKEN_HASH) {
		var value = par.value as String;
		if (value.length == 3) {
			var color = String::parse_hex_int(value);
			var r = (color >> 8) & 0xF;
			var g = (color >> 4) & 0xF;
			var b = (color >> 0) & 0xF;
			r |= r<<4;
			g |= g<<4;
			b |= b<<4;
			return ColorValue::create_rgb((r<<16)|(g<<8)|b);
		}
		if (value.length == 6) {
			return ColorValue::create_rgb(String::parse_hex_int(value));
		}
	}
	if (token == COMPONENT_FUNCTION) {
		var func = par.value as Function;
		var name = func.name.to_lower_case();
		rewind_buffer(func);
		if (name == "rgb" || name == "rgba") {
			var r, g, b, a = -1;
			if (next_is_integer(func)) {
				r = consume_integer(func);
				consume_comma(func);
				g = consume_integer(func);
				consume_comma(func);
				b = consume_integer(func);
			}
			else {
				var pr = consume_percentage(func);
				consume_comma(func);
				var pg = consume_percentage(func);
				consume_comma(func);
				var pb = consume_percentage(func);
				r = iround(pr * 255.0 / 100.0);
				g = iround(pg * 255.0 / 100.0);
				b = iround(pb * 255.0 / 100.0);
			}
			if (name == "rgba") {
				consume_comma(func);
				var fa = consume_float(func);
				a = iround(fa * 255.0);
			}
			consume_eof(func);
			r = clamp(r, 0, 255);
			g = clamp(g, 0, 255);
			b = clamp(b, 0, 255);
			if (a != -1) {
				a = clamp(a, 0, 255);
				return ColorValue::create_rgba((a<<24)|(r<<16)|(g<<8)|b);
			}
			return ColorValue::create_rgb((r<<16)|(g<<8)|b);
		}
		if (name == "hsl" || name == "hsla") {
			var a = -1;
			var h = consume_float(func);
			h = (iround(h) % 360 + 360) % 360;
			h /= 360.0;
			consume_comma(func);
			var s = fclamp(consume_percentage(func) / 100.0, 0.0, 1.0);
			consume_comma(func);
			var l = fclamp(consume_percentage(func) / 100.0, 0.0, 1.0);
			if (name == "hsla") {
				consume_comma(func);
				a = iround(consume_float(func) * 255.0);
			}
			consume_eof(func);
			var rgb = hsl_to_rgb(h, s, l);
			if (a != -1) {
				a = clamp(a, 0, 255);
				return ColorValue::create_rgba((a<<24)|rgb);
			}
			return ColorValue::create_rgb(rgb);
		}
	}
	back_token(par);
	return null;
}

function @next_is_url(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_URL) {
		back_token(par);
		return true;
	}
	back_token(par);
	return false;
}

function @parse_url(par: Parser): URLValue
{
	if (next_token(par) != TOKEN_URL) {
		throw error("not URL");
	}
	return URLValue::create(par.value as String);
}

function @next_is_image(par: Parser): Boolean
{
	var token = next_token(par);
	if (token == TOKEN_URL) {
		back_token(par);
		return true;
	}

	if (token == COMPONENT_FUNCTION) {
		var func = par.value as Function;
		var name = func.name.to_lower_case();
		if (name == "linear-gradient") {
			back_token(par);
			return true;
		}
	}

	back_token(par);
	return false;
}

function @parse_image(par: Parser): Value
{
	var token = next_token(par);
	if (token == COMPONENT_FUNCTION) {
		var func = par.value as Function;
		var name = func.name.to_lower_case();
		if (name == "linear-gradient") {
			rewind_buffer(func);
			consume_whitespace(func);

			var angle: Value;
			
			if (next_token(func) == TOKEN_IDENT && (func.value as String).to_lower_case() == "to") {
				consume_whitespace(func);
				if (next_token(func) != TOKEN_IDENT) throw error("bad direction");
				name = (func.value as String).to_lower_case();
				if (name == "top") {
					consume_whitespace(func);
					if (next_token(func) == TOKEN_IDENT) {
						name = (func.value as String).to_lower_case();
						if (name == "left") {
							angle = Value::create(VALUE_TO_TOP_LEFT);
						}
						else if (name == "right") {
							angle = Value::create(VALUE_TO_TOP_RIGHT);
						}
						else {
							throw error("syntax error");
						}
					}
					else {
						back_token(func);
					}
					if (!angle) {
						angle = Value::create(VALUE_TO_TOP);
					}
				}
				else if (name == "right") {
					consume_whitespace(func);
					if (next_token(func) == TOKEN_IDENT) {
						name = (func.value as String).to_lower_case();
						if (name == "top") {
							angle = Value::create(VALUE_TO_TOP_RIGHT);
						}
						else if (name == "bottom") {
							angle = Value::create(VALUE_TO_BOTTOM_RIGHT);
						}
						else {
							throw error("syntax error");
						}
					}
					else {
						back_token(func);
					}
					if (!angle) {
						angle = Value::create(VALUE_TO_RIGHT);
					}
				}
				else if (name == "bottom") {
					consume_whitespace(func);
					if (next_token(func) == TOKEN_IDENT) {
						name = (func.value as String).to_lower_case();
						if (name == "left") {
							angle = Value::create(VALUE_TO_BOTTOM_LEFT);
						}
						else if (name == "right") {
							angle = Value::create(VALUE_TO_BOTTOM_RIGHT);
						}
						else {
							throw error("syntax error");
						}
					}
					else {
						back_token(func);
					}
					if (!angle) {
						angle = Value::create(VALUE_TO_BOTTOM);
					}
				}
				else if (name == "left") {
					consume_whitespace(func);
					if (next_token(func) == TOKEN_IDENT) {
						name = (func.value as String).to_lower_case();
						if (name == "top") {
							angle = Value::create(VALUE_TO_TOP_LEFT);
						}
						else if (name == "bottom") {
							angle = Value::create(VALUE_TO_BOTTOM_LEFT);
						}
						else {
							throw error("syntax error");
						}
					}
					else {
						back_token(func);
					}
					if (!angle) {
						angle = Value::create(VALUE_TO_LEFT);
					}
				}
			}
			else {
				back_token(func);
				angle = parse_angle(func);
			}

			if (angle) {
				consume_whitespace(func);
				if (next_token(func) != TOKEN_COMMA) {
					throw error("expected comma");
				}
			}

			if (!angle) {
				angle = Value::create(VALUE_TO_BOTTOM);
			}

			var gradient = LinearGradientValue::create(angle);

			for (;;) {
				consume_whitespace(func);
				var color = parse_color(func);
				if (!color) throw error("expected color");

				var group = GroupValue::create();
				group.add_child(color);

				consume_whitespace(func);
				if (next_is_length_percentage(func)) {
					group.add_child(parse_length_percentage(func));
				}

				gradient.add_child(group);

				consume_whitespace(func);
				if (next_token(func) != TOKEN_COMMA) {
					back_token(func);
					break;
				}
			}

			consume_whitespace(func);
			if (next_token(func) != TOKEN_EOF) {
				throw error("expected EOF");
			}
			return gradient;
		}
	}

	back_token(par);
	return parse_url(par);
}

function @next_is_length(par: Parser): Boolean
{
	var token = next_token(par);
	if (token == TOKEN_NUMBER) {
		var value = par.value as Number;
		if (value.repr == "0") {
			back_token(par);
			return true;
		}
	}
	else if (token == TOKEN_DIMENSION) {
		back_token(par);
		return true;
	}

	back_token(par);
	return false;
}

function parse_length(par: Parser): LengthValue
{
	var token = next_token(par);
	if (token == TOKEN_NUMBER) {
		var value = par.value as Number;
		if (value.repr == "0") {
			return LengthValue::create(0, UNIT_ZERO);
		}
	}
	else if (token == TOKEN_DIMENSION) {
		var value = (par.value as Number).as_float();
		var unit = (par as [DimensionToken])[0 as DimensionToken].unit.to_lower_case();
		switch (unit[0]) {
			case 'e':
				if (unit == "em") return LengthValue::create(value, UNIT_EM);
				if (unit == "ex") return LengthValue::create(value, UNIT_EX);
				break;

			case 'c':
				if (unit == "cm") return LengthValue::create(value, UNIT_CM);
				if (unit == "ch") return LengthValue::create(value, UNIT_CH);
				break;

			case 'r':
				if (unit == "rem") return LengthValue::create(value, UNIT_REM);
				break;

			case 'v':
				if (unit == "vw") return LengthValue::create(value, UNIT_VW);
				if (unit == "vh") return LengthValue::create(value, UNIT_VH);
				if (unit == "vmin") return LengthValue::create(value, UNIT_VMIN);
				if (unit == "vmax") return LengthValue::create(value, UNIT_VMAX);
				break;

			case 'm':
				if (unit == "mm") return LengthValue::create(value, UNIT_MM);
				break;

			case 'q':
				if (unit == "q") return LengthValue::create(value, UNIT_Q);
				break;

			case 'i':
				if (unit == "in") return LengthValue::create(value, UNIT_IN);
				break;

			case 'p':
				if (unit == "px") return LengthValue::create(value, UNIT_PX);
				if (unit == "pt") return LengthValue::create(value, UNIT_PT);
				if (unit == "pc") return LengthValue::create(value, UNIT_PC);
				break;
		}
		throw error("invalid length unit");
	}

	throw error("not length");
}

function @next_is_length_percentage(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_PERCENTAGE) {
		back_token(par);
		return true;
	}

	back_token(par);
	return next_is_length(par);
}

function @parse_length_percentage(par: Parser): LengthValue
{
	if (next_token(par) == TOKEN_PERCENTAGE) {
		var value = (par.value as Number).as_float();
		return LengthValue::create(value, UNIT_PERCENT);
	}

	back_token(par);
	return parse_length(par);
}

function @parse_angle(par: Parser): AngleValue
{
	var token = next_token(par);
	if (token == TOKEN_DIMENSION) {
		var value = (par.value as Number).as_float();
		var unit = (par as [DimensionToken])[0 as DimensionToken].unit.to_lower_case();
		switch (unit[0]) {
			case 'd':
				if (unit == "deg") return AngleValue::create(value, UNIT_DEG);
				break;

			case 'g':
				if (unit == "grad") return AngleValue::create(value, UNIT_GRAD);
				break;

			case 'r':
				if (unit == "rad") return AngleValue::create(value, UNIT_RAD);
				break;

			case 't':
				if (unit == "turn") return AngleValue::create(value, UNIT_TURN);
				break;
		}
	}

	back_token(par);
	return null;
}

function @parse_multiple(par: Parser, func): Value
{
	var multiple = MultipleValue::create();

	do {
		consume_whitespace(par);
		var value = func(par);
		if (!value) throw error("expected value");
		multiple.add_child(value);
		consume_whitespace(par);
	}
	while (next_token(par) == TOKEN_COMMA);

	if (par.type != TOKEN_EOF) {
		throw error("expected EOF");
	}

	if (multiple.get_child_count() == 1) {
		return multiple.get_child(0);
	}
	return multiple;
}

function @next_is_background_image(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "none") {
		back_token(par);
		return true;
	}

	back_token(par);
	return next_is_image(par);
}

function @parse_background_image(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "none") {
		return Value::create(VALUE_NONE);
	}
	else {
		back_token(par);
		return parse_image(par);
	}
}

function @next_is_background_repeat(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "repeat-x" || name == "repeat-y" || name == "repeat" || name == "space" || name == "round" || name == "no-repeat") {
			back_token(par);
			return true;
		}
	}

	back_token(par);
	return false;
}

function @parse_background_repeat(par: Parser): GroupValue
{
	var name = expect_ident(par);

	if (name == "repeat-x") {
		return GroupValue::create(Value::create(VALUE_REPEAT), Value::create(VALUE_NO_REPEAT));
	}
	if (name == "repeat-y") {
		return GroupValue::create(Value::create(VALUE_NO_REPEAT), Value::create(VALUE_REPEAT));
	}

	var group = GroupValue::create();

	for (var i=0; i<2; i++) {
		if (name == "repeat") {
			group.add_child(Value::create(VALUE_REPEAT));
		}
		else if (name == "space") {
			group.add_child(Value::create(VALUE_SPACE));
		}
		else if (name == "round") {
			group.add_child(Value::create(VALUE_ROUND));
		}
		else if (name == "no-repeat") {
			group.add_child(Value::create(VALUE_NO_REPEAT));
		}
		else {
			if (i == 1) {
				back_token(par);
				break;
			}
			throw error("unknown repeat value");
		}

		consume_whitespace(par);
		if (next_token(par) != TOKEN_IDENT) {
			back_token(par);
			break;
		}

		name = (par.value as String).to_lower_case();
	}

	if (group.get_child_count() == 1) {
		group.add_child(group.get_child(0));
	}

	return group;
}

function @next_is_background_attachment(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "fixed" || name == "local" || name == "scroll") {
			back_token(par);
			return true;
		}
	}

	back_token(par);
	return false;
}

function @parse_background_attachment(par: Parser): Value
{
	var name = expect_ident(par);

	if (name == "fixed") {
		return Value::create(VALUE_FIXED);
	}
	if (name == "local") {
		return Value::create(VALUE_LOCAL);
	}
	if (name == "scroll") {
		return Value::create(VALUE_SCROLL);
	}

	throw error("unknown attachment value");
}

function @parse_background_position_value(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "left") return Value::create(VALUE_LEFT);
		if (name == "center") return Value::create(VALUE_CENTER);
		if (name == "right") return Value::create(VALUE_RIGHT);
		if (name == "top") return Value::create(VALUE_TOP);
		if (name == "bottom") return Value::create(VALUE_BOTTOM);
		back_token(par);
		return null;
	}
	
	back_token(par);
	if (next_is_length_percentage(par)) {
		return parse_length_percentage(par);
	}
	return null;
}

function @bgpos_value_is_dir(value: Value): Boolean
{
	switch (value.type) {
		case VALUE_LEFT:
		case VALUE_RIGHT:
		case VALUE_TOP:
		case VALUE_BOTTOM:
			return true;
	}
	return false;
}

function @bgpos_value_is_horiz(value: Value): Boolean
{
	switch (value.type) {
		case VALUE_LEFT:
		case VALUE_RIGHT:
			return true;
	}
	return false;
}

function @bgpos_value_is_vert(value: Value): Boolean
{
	switch (value.type) {
		case VALUE_TOP:
		case VALUE_BOTTOM:
			return true;
	}
	return false;
}

function @next_is_background_position(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "left" || name == "center" || name == "right" || name == "top" || name == "bottom") {
			back_token(par);
			return true;
		}
	}
	
	back_token(par);
	return next_is_length_percentage(par);
}

function @parse_background_position(par: Parser): GroupValue
{
	var v1: Value, v2: Value, v3: Value, v4: Value;
	
	v1 = parse_background_position_value(par);
	if (!v1) throw error("expected position value");
	//log("v1="+v1.to_string());
	
	consume_whitespace(par);
	v2 = parse_background_position_value(par);
	if (v2) {
		//log("v2="+v2.to_string());
		consume_whitespace(par);
		v3 = parse_background_position_value(par);
		if (v3) {
			//log("v3="+v3.to_string());
			consume_whitespace(par);
			v4 = parse_background_position_value(par);
			//if (v4) {
			//	log("v4="+v4.to_string());
			//}
		}
	}

	if (!v2) {
		if (bgpos_value_is_vert(v1)) {
			return GroupValue::create(Value::create(VALUE_CENTER), v1);
		}
		return GroupValue::create(v1, Value::create(VALUE_CENTER));
	}

	if (!v3) {
		if (bgpos_value_is_vert(v1)) {
			if (bgpos_value_is_vert(v2)) {
				throw error("duplicate direction in position");
			}
			return GroupValue::create(v2, v1);
		}
		if (bgpos_value_is_horiz(v2)) {
			throw error("duplicate direction in position");
		}
		return GroupValue::create(v1, Value::create(VALUE_CENTER));
	}

	if (!v4) {
		if (bgpos_value_is_dir(v1) && v2.type != VALUE_LENGTH) {
			v4 = v3;
			v3 = v2;
			v2 = LengthValue::create(0, UNIT_ZERO);
		}
		else {
			v4 = LengthValue::create(0, UNIT_ZERO);
		}
	}

	if (v2.type != VALUE_LENGTH || v4.type != VALUE_LENGTH) {
		throw error("invalid position value");
	}

	if (bgpos_value_is_horiz(v1) && bgpos_value_is_vert(v3)) {
		return GroupValue::create(GroupValue::create(v1, v2), GroupValue::create(v3, v4));
	}

	if (bgpos_value_is_vert(v1) && bgpos_value_is_horiz(v3)) {
		return GroupValue::create(GroupValue::create(v3, v4), GroupValue::create(v1, v2));
	}

	throw error("invalid position value");
}

function @next_is_background_clip(par: Parser): Boolean
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "border-box" || name == "padding-box" || name == "content-box") {
			back_token(par);
			return true;
		}
	}

	back_token(par);
	return false;
}

function @parse_background_clip(par: Parser): Value
{
	var name = expect_ident(par);

	if (name == "border-box") {
		return Value::create(VALUE_BORDER_BOX);
	}
	if (name == "padding-box") {
		return Value::create(VALUE_PADDING_BOX);
	}
	if (name == "content-box") {
		return Value::create(VALUE_CONTENT_BOX);
	}

	throw error("unknown clip value");
}

function @parse_background_size(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "cover") {
			return Value::create(VALUE_COVER);
		}
		if (name == "contain") {
			return Value::create(VALUE_CONTAIN);
		}

		if (name == "auto") {
			consume_whitespace(par);
			token = next_token(par);
			if (token == TOKEN_IDENT) {
				name = (par.value as String).to_lower_case();
				if (name == "auto") {
					return GroupValue::create(Value::create(VALUE_AUTO), Value::create(VALUE_AUTO));
				}
			}
			back_token(par);
			if (next_is_length_percentage(par)) {
				return GroupValue::create(Value::create(VALUE_AUTO), parse_length_percentage(par));
			}
			return GroupValue::create(Value::create(VALUE_AUTO), Value::create(VALUE_AUTO));
		}
	}

	back_token(par);
	var v1 = parse_length_percentage(par);

	consume_whitespace(par);
	token = next_token(par);
	if (token == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "auto") {
			return GroupValue::create(v1, Value::create(VALUE_AUTO));
		}
	}
	back_token(par);
	if (next_is_length_percentage(par)) {
		return GroupValue::create(v1, parse_length_percentage(par));
	}
	return GroupValue::create(v1, Value::create(VALUE_AUTO));
}

function @parse_background_value(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (;;) {
		consume_whitespace(par);

		if (next_is_background_image(par)) {
			group.add_child(parse_background_image(par));
			continue;
		}

		if (next_is_background_position(par)) {
			group.add_child(parse_background_position(par));
			consume_whitespace(par);
			if (next_token(par) == TOKEN_DELIM && (par.value as Integer) == '/') {
				consume_whitespace(par);
				group.add_child(parse_background_size(par));
			}
			back_token(par);
			continue;
		}

		if (next_is_background_repeat(par)) {
			group.add_child(parse_background_repeat(par));
			continue;
		}

		if (next_is_background_attachment(par)) {
			group.add_child(parse_background_attachment(par));
			continue;
		}

		if (next_is_background_clip(par)) {
			group.add_child(parse_background_clip(par));
			continue;
		}

		var color = parse_color(par);
		if (color) {
			group.add_child(color);
			continue;
		}

		break;
	}

	if (group.get_child_count() == 0) {
		throw error("empty background layer");
	}
	return group;
}

function @parse_background(par: Parser): Value
{
	var multiple_or_single = parse_multiple(par, parse_background_value#1);

	if (multiple_or_single.type == VALUE_MULTIPLE) {
		var multiple = multiple_or_single as MultipleValue;
		for (var i=0; i<multiple.get_child_count()-1; i++) {
			var group = multiple.get_child(i) as GroupValue;
			for (var j=0; j<group.get_child_count(); j++) {
				if (ColorValue::is_instance(group.get_child(j))) {
					throw error("color is permitted only in final layer");
				}
			}
		}
	}
	return multiple_or_single;
}

function @parse_border_group(par: Parser, func): GroupValue
{
	var group = GroupValue::create();

	for (var i=0; i<4; i++) {
		consume_whitespace(par);
		var value = func(par);
		if (!value) break;
		group.add_child(value);
	}

	if (group.get_child_count() == 0) {
		throw error("no border values present");
	}
	if (group.get_child_count() == 1) {
		group.add_child(group.get_child(0));
	}
	if (group.get_child_count() == 2) {
		group.add_child(group.get_child(0));
	}
	if (group.get_child_count() == 3) {
		group.add_child(group.get_child(1));
	}
	return group;
}

function @parse_border_color(par: Parser): GroupValue
{
	return parse_border_group(par, parse_color#1);
}

function @parse_border_style_value(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "none":   return Value::create(VALUE_NONE);
			case "hidden": return Value::create(VALUE_HIDDEN);
			case "dotted": return Value::create(VALUE_DOTTED);
			case "dashed": return Value::create(VALUE_DASHED);
			case "solid":  return Value::create(VALUE_SOLID);
			case "double": return Value::create(VALUE_DOUBLE);
			case "groove": return Value::create(VALUE_GROOVE);
			case "ridge":  return Value::create(VALUE_RIDGE);
			case "inset":  return Value::create(VALUE_INSET);
			case "outset": return Value::create(VALUE_OUTSET);
		}
	}

	back_token(par);
	return null;
}

function @parse_border_style(par: Parser): GroupValue
{
	return parse_border_group(par, parse_border_style_value#1);
}

function @parse_border_width_value(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "thin") return Value::create(VALUE_THIN);
		if (name == "medium") return Value::create(VALUE_MEDIUM);
		if (name == "thick") return Value::create(VALUE_THICK);
	}

	back_token(par);
	if (next_is_length(par)) {
		return parse_length(par);
	}
	return null;
}

function @parse_border_width(par: Parser): GroupValue
{
	return parse_border_group(par, parse_border_width_value#1);
}

function @parse_border(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (;;) {
		consume_whitespace(par);

		var value = parse_border_width_value(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_border_style_value(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_color(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		break;
	}

	if (group.get_child_count() == 0) {
		throw error("no border values present");
	}
	return group;
}

function @parse_border_radius_value(par: Parser): GroupValue
{
	var v1 = parse_length_percentage(par);
	var v2 = v1;
	
	consume_whitespace(par);
	if (next_is_length_percentage(par)) {
		v2 = parse_length_percentage(par);
	}
	return GroupValue::create(v1, v2);
}

function @parse_border_radius_group(par: Parser, group: GroupValue)
{
	for (var i=0; i<4; i++) {
		consume_whitespace(par);
		if (next_is_length_percentage(par)) {
			group.add_child(parse_length_percentage(par));
		}
		else break;
	}
	if (group.get_child_count() == 0) {
		throw error("no values present");
	}
	if (group.get_child_count() == 1) {
		group.add_child(group.get_child(0));
	}
	if (group.get_child_count() == 2) {
		group.add_child(group.get_child(0));
	}
	if (group.get_child_count() == 3) {
		group.add_child(group.get_child(1));
	}
}

function @parse_border_radius(par: Parser): SlashGroupValue
{
	var group1 = GroupValue::create();
	var group2;

	parse_border_radius_group(par, group1);

	if (next_token(par) == TOKEN_DELIM && (par.value as Integer) == '/') {
		group2 = GroupValue::create();
		parse_border_radius_group(par, group2);
	}
	else {
		back_token(par);
		group2 = group1;
	}
	return SlashGroupValue::create(group1, group2);
}

function @parse_border_collapse(par: Parser): Value
{
	var name = expect_ident(par);
	if (name == "collapse") return Value::create(VALUE_COLLAPSE);
	if (name == "separate") return Value::create(VALUE_SEPARATE);
	throw error("invalid border collapse value");
}

function @parse_border_spacing(par: Parser): GroupValue
{
	var horiz = parse_length(par);
	var vert = horiz;

	consume_whitespace(par);
	if (next_is_length(par)) {
		vert = parse_length(par);
	}
	return GroupValue::create(horiz, vert);
}

function @parse_box_shadow_value(par: Parser): GroupValue
{
	var group = GroupValue::create();

	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "inset") {
		group.add_child(Value::create(VALUE_INSET));
	}
	else {
		back_token(par);
	}

	for (var i=0; i<4; i++) {
		consume_whitespace(par);
		if (next_is_length(par)) {
			group.add_child(parse_length(par));
		}
		else {
			if (i <= 1) {
				throw error("both offsets required");
			}
			break;
		}
	}

	consume_whitespace(par);
	var color = parse_color(par);
	if (color) {
		group.add_child(color);
	}

	// TODO: inset can be also last? or is the position irrelevant for all values?
	consume_whitespace(par);
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "inset") {
		if (group.get_child(0).type != VALUE_INSET) {
			group.insert_child(0, Value::create(VALUE_INSET));
		}
	}
	else {
		back_token(par);
	}
	return group;
}

function @parse_box_shadow(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "none") {
			return Value::create(VALUE_NONE);
		}
	}

	back_token(par);
	return parse_multiple(par, parse_box_shadow_value#1);
}

function @parse_text_shadow_value(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (var i=0; i<3; i++) {
		consume_whitespace(par);
		if (next_is_length(par)) {
			group.add_child(parse_length(par));
		}
		else {
			if (i <= 1) {
				throw error("both offsets required");
			}
			break;
		}
	}

	consume_whitespace(par);
	var color = parse_color(par);
	if (color) {
		group.add_child(color);
	}

	return group;
}

function @parse_text_shadow(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "none") {
			return Value::create(VALUE_NONE);
		}
	}

	back_token(par);
	return parse_multiple(par, parse_text_shadow_value#1);
}

function @parse_opacity(par: Parser): OpacityValue
{
	var opacity = consume_float(par);
	opacity = fclamp(opacity, 0.0, 1.0);
	return OpacityValue::create(opacity);
}

function @parse_font_family(par: Parser): FontFamilyValue
{
	var token = next_token(par);
	if (token == TOKEN_STRING) {
		return FontFamilyValue::create(par.value as String);
	}

	if (token != TOKEN_IDENT) {
		back_token(par);
		return null;
	}

	var s = {par.value as String};
	for (;;) {
		consume_whitespace(par);
		token = next_token(par);
		if (token != TOKEN_IDENT) {
			back_token(par);
			break;
		}
		s[] = ' ';
		s += par.value as String;
	}

	if (s == "serif" || s == "sans-serif" || s == "cursive" || s == "fantasy" || s == "monospace") {
		return FontFamilyValue::create_generic(s);
	}
	return FontFamilyValue::create(s);
}

function @parse_font_weight(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "normal") return FontWeightValue::create(400);
		if (name == "bold") return FontWeightValue::create(700);
		if (name == "bolder") return Value::create(VALUE_BOLDER);
		if (name == "lighter") return Value::create(VALUE_LIGHTER);
	}
	else if (token == TOKEN_NUMBER) {
		var value = par.value as Number;
		if (value.repr[0] != '+' && !value.is_number) {
			switch (value.value as Integer) {
				case 100, 200, 300, 400, 500, 600, 700, 800, 900:
					return FontWeightValue::create(value.value as Integer);
			}
		}
	}
	back_token(par);
	return null;
}

function @parse_font_style(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		if (name == "normal") return Value::create(VALUE_NORMAL);
		if (name == "italic") return Value::create(VALUE_ITALIC);
		if (name == "oblique") return Value::create(VALUE_OBLIQUE);
	}
	back_token(par);
	return null;
}

function @parse_font_size(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "xx-small": return Value::create(VALUE_XX_SMALL);
			case "x-small":  return Value::create(VALUE_X_SMALL);
			case "small":    return Value::create(VALUE_SMALL);
			case "medium":   return Value::create(VALUE_MEDIUM);
			case "large":    return Value::create(VALUE_LARGE);
			case "x-large":  return Value::create(VALUE_X_LARGE);
			case "xx-large": return Value::create(VALUE_XX_LARGE);
			case "larger":   return Value::create(VALUE_LARGER);
			case "smaller":  return Value::create(VALUE_SMALLER);
		}
	}

	back_token(par);
	if (next_is_length_percentage(par)) {
		return parse_length_percentage(par);
	}
	return null;
}

function @parse_font(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (;;) {
		consume_whitespace(par);

		var value = parse_font_style(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_font_weight(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_font_size(par);
		if (value) {
			consume_whitespace(par);
			if (next_token(par) == TOKEN_DELIM && (par.value as Integer) == '/') {
				consume_whitespace(par);
				group.add_child(SlashGroupValue::create(value, parse_line_height(par)));
			}
			else {
				back_token(par);
				group.add_child(value);
			}
			continue;
		}

		value = parse_font_family(par);
		if (value) {
			var multiple = MultipleValue::create();
			multiple.add_child(value);

			for (;;) {
				consume_whitespace(par);
				if (next_token(par) != TOKEN_COMMA) {
					back_token(par);
					break;
				}
				
				consume_whitespace(par);
				value = parse_font_family(par);
				if (!value) throw error("expected font family");
				multiple.add_child(value);
			}

			if (multiple.get_child_count() == 1) {
				group.add_child(multiple.get_child(0));
			}
			else {
				group.add_child(multiple);
			}
			continue;
		}

		break;
	}

	if (group.get_child_count() == 0) {
		throw error("no font values present");
	}
	return group;
}

function @parse_line_height(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT && (par.value as String).to_lower_case() == "normal") {
		return Value::create(VALUE_NORMAL);
	}

	if (token == TOKEN_NUMBER) {
		return NumberValue::create((par.value as Number).as_float());
	}

	back_token(par);
	return parse_length_percentage(par);
}

function @parse_margin_value(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	if (next_is_length_percentage(par)) {
		return parse_length_percentage(par);
	}
	return null;
}

function @parse_margin(par: Parser): GroupValue
{
	return parse_border_group(par, parse_margin_value#1);
}

function @parse_padding_value(par: Parser): LengthValue
{
	if (next_is_length_percentage(par)) {
		return parse_length_percentage(par);
	}
	return null;
}

function @parse_padding(par: Parser): GroupValue
{
	return parse_border_group(par, parse_padding_value#1);
}

function @parse_display(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "inline":             return Value::create(VALUE_INLINE);
		case "block":              return Value::create(VALUE_BLOCK);
		case "list-item":          return Value::create(VALUE_LIST_ITEM);
		case "inline-block":       return Value::create(VALUE_INLINE_BLOCK);
		case "table":              return Value::create(VALUE_TABLE);
		case "inline-table":       return Value::create(VALUE_INLINE_TABLE);
		case "table-row-group":    return Value::create(VALUE_TABLE_ROW_GROUP);
		case "table-header-group": return Value::create(VALUE_TABLE_HEADER_GROUP);
		case "table-footer-group": return Value::create(VALUE_TABLE_FOOTER_GROUP);
		case "table-row":          return Value::create(VALUE_TABLE_ROW);
		case "table-column-group": return Value::create(VALUE_TABLE_COLUMN_GROUP);
		case "table-column":       return Value::create(VALUE_TABLE_COLUMN);
		case "table-cell":         return Value::create(VALUE_TABLE_CELL);
		case "table-caption":      return Value::create(VALUE_TABLE_CAPTION);
		case "flex":               return Value::create(VALUE_FLEX);
		case "inline-flex":        return Value::create(VALUE_INLINE_FLEX);
		case "none":               return Value::create(VALUE_NONE);
	}
	throw error("invalid display value");
}

function @parse_position(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "static":   return Value::create(VALUE_STATIC);
		case "relative": return Value::create(VALUE_RELATIVE);
		case "absolute": return Value::create(VALUE_ABSOLUTE);
		case "fixed":    return Value::create(VALUE_FIXED);
	}
	throw error("invalid position value");
}

function @parse_box_offset(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	return parse_length_percentage(par);
}

function @parse_float(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "left":  return Value::create(VALUE_LEFT);
		case "right": return Value::create(VALUE_RIGHT);
		case "none":  return Value::create(VALUE_NONE);
	}
	throw error("invalid float value");
}

function @parse_clear(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "none":  return Value::create(VALUE_NONE);
		case "left":  return Value::create(VALUE_LEFT);
		case "right": return Value::create(VALUE_RIGHT);
		case "both":  return Value::create(VALUE_BOTH);
	}
	throw error("invalid clear value");
}

function @parse_z_index(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	if (token != TOKEN_NUMBER || (par.value as Number).is_number) {
		throw error("expected integer or auto");
	}
	return IntegerValue::create((par.value as Number).value as Integer);
}

function @parse_width_height(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	return parse_length_percentage(par);
}

function @parse_max_width_height(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "none") {
		return Value::create(VALUE_NONE);
	}

	back_token(par);
	return parse_length_percentage(par);
}

function @parse_vertical_align(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "baseline":    return Value::create(VALUE_BASELINE);
			case "sub":         return Value::create(VALUE_SUB);
			case "super":       return Value::create(VALUE_SUPER);
			case "top":         return Value::create(VALUE_TOP);
			case "text-top":    return Value::create(VALUE_TEXT_TOP);
			case "middle":      return Value::create(VALUE_MIDDLE);
			case "bottom":      return Value::create(VALUE_BOTTOM);
			case "text-bottom": return Value::create(VALUE_TEXT_BOTTOM);
		}
	}

	back_token(par);
	return parse_length_percentage(par);
}

function @parse_box_sizing(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "border-box":  return Value::create(VALUE_BORDER_BOX);
		case "content-box": return Value::create(VALUE_CONTENT_BOX);
	}
	throw error("invalid box sizing value");
}

function @parse_text_align(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "left":    return Value::create(VALUE_LEFT);
		case "right":   return Value::create(VALUE_RIGHT);
		case "center":  return Value::create(VALUE_CENTER);
		case "justify": return Value::create(VALUE_JUSTIFY);
	}
	throw error("invalid text align value");
}

function @parse_text_decoration(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "none":         return Value::create(VALUE_NONE);
		case "underline":    return Value::create(VALUE_UNDERLINE);
		case "overline":     return Value::create(VALUE_OVERLINE);
		case "line-through": return Value::create(VALUE_LINE_THROUGH);
		case "blink":        return Value::create(VALUE_BLINK);
	}
	throw error("invalid text decoration value");
}

function @parse_letter_word_spacing(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "normal") {
		return Value::create(VALUE_NORMAL);
	}

	back_token(par);
	return parse_length(par);
}

function @parse_text_transform(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "capitalize": return Value::create(VALUE_CAPITALIZE);
		case "uppercase":  return Value::create(VALUE_UPPERCASE);
		case "lowercase":  return Value::create(VALUE_LOWERCASE);
		case "none":       return Value::create(VALUE_NONE);
	}
	throw error("invalid text transform value");
}

function @parse_white_space(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "normal":   return Value::create(VALUE_NORMAL);
		case "pre":      return Value::create(VALUE_PRE);
		case "nowrap":   return Value::create(VALUE_NOWRAP);
		case "pre-wrap": return Value::create(VALUE_PRE_WRAP);
		case "pre-line": return Value::create(VALUE_PRE_LINE);
	}
	throw error("invalid white space value");
}

function @parse_overflow(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "visible": return Value::create(VALUE_VISIBLE);
		case "hidden":  return Value::create(VALUE_HIDDEN);
		case "scroll":  return Value::create(VALUE_SCROLL);
		case "auto":    return Value::create(VALUE_AUTO);
	}
	throw error("invalid overflow value");
}

function @parse_clip_value(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	return parse_length(par);
}

function @parse_clip(par: Parser): Value
{
	var token = next_token(par);
	if (token == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	if (token != COMPONENT_FUNCTION) {
		throw error("expected rect function");
	}

	var func = par.value as Function;
	if (func.name.to_lower_case() != "rect") {
		throw error("expected rect function");
	}

	rewind_buffer(func);
	consume_whitespace(func);
	var top = parse_clip_value(func);
	consume_comma(func);
	consume_whitespace(func);
	var right = parse_clip_value(func);
	consume_comma(func);
	consume_whitespace(func);
	var bottom = parse_clip_value(func);
	consume_comma(func);
	consume_whitespace(func);
	var left = parse_clip_value(func);
	consume_whitespace(func);
	
	if (next_token(func) != TOKEN_EOF) {
		throw error("invalid rect parameters");
	}

	return RectValue::create(top, right, bottom, left);
}

function @parse_visibility(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "visible":  return Value::create(VALUE_VISIBLE);
		case "hidden":   return Value::create(VALUE_HIDDEN);
		case "collapse": return Value::create(VALUE_COLLAPSE);
	}
	throw error("invalid visibility value");
}

function @parse_list_style_type(par: Parser): Value
{
	if (next_token(par) != TOKEN_IDENT) {
		back_token(par);
		return null;
	}
	var name = (par.value as String).to_lower_case();
	switch (name) {
		case "none":                 return Value::create(VALUE_NONE);
		case "disc":                 return Value::create(VALUE_DISC);
		case "circle":               return Value::create(VALUE_CIRCLE);
		case "square":               return Value::create(VALUE_SQUARE);
		case "decimal":              return Value::create(VALUE_DECIMAL);
		case "decimal-leading-zero": return Value::create(VALUE_DECIMAL_LEADING_ZERO);
		case "lower-roman":          return Value::create(VALUE_LOWER_ROMAN);
		case "upper-roman":          return Value::create(VALUE_UPPER_ROMAN);
		case "lower-greek":          return Value::create(VALUE_LOWER_GREEK);
		case "lower-latin":          return Value::create(VALUE_LOWER_LATIN);
		case "upper-latin":          return Value::create(VALUE_UPPER_LATIN);
		case "armenian":             return Value::create(VALUE_ARMENIAN);
		case "georgian":             return Value::create(VALUE_GEORGIAN);
		case "lower-alpha":          return Value::create(VALUE_LOWER_ALPHA);
		case "upper-alpha":          return Value::create(VALUE_UPPER_ALPHA);
	}
	back_token(par);
	return null;
}

function @parse_list_style_image(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "none") {
		return Value::create(VALUE_NONE);
	}

	back_token(par);
	if (!next_is_image(par)) {
		return null;
	}
	return parse_image(par);
}

function @parse_list_style_position(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "inside":  return Value::create(VALUE_INSIDE);
			case "outside": return Value::create(VALUE_OUTSIDE);
		}
	}
	back_token(par);
	return null;
}

function @parse_list_style(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (;;) {
		consume_whitespace(par);

		var value = parse_list_style_type(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_list_style_position(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_list_style_image(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		break;
	}

	if (group.get_child_count() == 0) {
		throw error("no list style values present");
	}
	return group;
}

function @parse_content(par: Parser): ContentTextValue
{
	var token = next_token(par);
	if (token == TOKEN_STRING) {
		return ContentTextValue::create(par.value as String);
	}
	throw error("only string is accepted");
}

function @parse_flex_direction(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "row":            return Value::create(VALUE_ROW);
			case "row-reverse":    return Value::create(VALUE_ROW_REVERSE);
			case "column":         return Value::create(VALUE_COLUMN);
			case "column-reverse": return Value::create(VALUE_COLUMN_REVERSE);
		}
	}

	back_token(par);
	return null;
}

function @parse_flex_wrap(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT) {
		var name = (par.value as String).to_lower_case();
		switch (name) {
			case "nowrap":       return Value::create(VALUE_NOWRAP);
			case "wrap":         return Value::create(VALUE_WRAP);
			case "wrap-reverse": return Value::create(VALUE_WRAP_REVERSE);
		}
	}

	back_token(par);
	return null;
}

function @parse_flex_flow(par: Parser): GroupValue
{
	var group = GroupValue::create();

	for (;;) {
		consume_whitespace(par);

		var value = parse_flex_direction(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		value = parse_flex_wrap(par);
		if (value) {
			group.add_child(value);
			continue;
		}

		break;
	}

	if (group.get_child_count() == 0) {
		throw error("no flex flow values present");
	}
	return group;
}

function @parse_order(par: Parser): IntegerValue
{
	var order = consume_integer(par);
	return IntegerValue::create(order);
}

function @parse_flex_grow_shrink(par: Parser): NumberValue
{
	if (next_token(par) != TOKEN_NUMBER) {
		back_token(par);
		return null;
	}
	var factor = (par.value as Number).as_float();
	if (factor < 0.0) {
		throw error("negative factor not allowed");
	}
	return NumberValue::create(factor);
}

function @parse_flex_basis(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "content") {
		return Value::create(VALUE_CONTENT);
	}

	back_token(par);

	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	if (next_is_length_percentage(par)) {
		return parse_length_percentage(par);
	}
	return null;
}

function @parse_flex(par: Parser): Value
{
	if (next_token(par) == TOKEN_IDENT && (par.value as String).to_lower_case() == "none") {
		return Value::create(VALUE_NONE);
	}

	var group = GroupValue::create();

	var grow = parse_flex_grow_shrink(par);
	if (grow) {
		group.add_child(grow);

		consume_whitespace(par);
		var shrink = parse_flex_grow_shrink(par);
		if (shrink) {
			group.add_child(shrink);
			consume_whitespace(par);
		}

		var basis = parse_flex_basis(par);
		if (basis) {
			group.add_child(basis);
		}
	}
	else {
		var basis = parse_flex_basis(par);
		if (!basis) {
			return null;
		}
		group.add_child(basis);
	
		consume_whitespace(par);
		grow = parse_flex_grow_shrink(par);
		if (grow) {
			group.add_child(grow);
		
			consume_whitespace(par);
			var shrink = parse_flex_grow_shrink(par);
			if (shrink) {
				group.add_child(shrink);
			}
		}
	}

	return group;
}

function @parse_justify_content(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "flex-start":    return Value::create(VALUE_FLEX_START);
		case "flex-end":      return Value::create(VALUE_FLEX_END);
		case "center":        return Value::create(VALUE_CENTER);
		case "space-between": return Value::create(VALUE_SPACE_BETWEEN);
		case "space-around":  return Value::create(VALUE_SPACE_AROUND);
	}
	throw error("invalid justify content value");
}

function @parse_align_items(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "flex-start": return Value::create(VALUE_FLEX_START);
		case "flex-end":   return Value::create(VALUE_FLEX_END);
		case "center":     return Value::create(VALUE_CENTER);
		case "baseline":   return Value::create(VALUE_BASELINE);
		case "stretch":    return Value::create(VALUE_STRETCH);
	}
	throw error("invalid align items value");
}

function @parse_align_self(par: Parser): Value
{
	var name = expect_ident(par);
	if (name == "auto") {
		return Value::create(VALUE_AUTO);
	}

	back_token(par);
	return parse_align_items(par);
}

function @parse_align_content(par: Parser): Value
{
	var name = expect_ident(par);
	switch (name) {
		case "flex-start":    return Value::create(VALUE_FLEX_START);
		case "flex-end":      return Value::create(VALUE_FLEX_END);
		case "center":        return Value::create(VALUE_CENTER);
		case "space-around":  return Value::create(VALUE_SPACE_AROUND);
		case "space-between": return Value::create(VALUE_SPACE_BETWEEN);
		case "stretch":       return Value::create(VALUE_STRETCH);
	}
	throw error("invalid align content value");
}

function @parse_tab_size(par: Parser): IntegerValue
{
	var token = next_token(par);
	if (token != TOKEN_NUMBER || (par.value as Number).is_number) {
		throw error("expected integer");
	}
	return IntegerValue::create((par.value as Number).value as Integer);
}

function @parse_cursor(par: Parser): Value
{
	do {
		consume_whitespace(par);
		if (next_token(par) == TOKEN_IDENT) {
			var name = (par.value as String).to_lower_case();
			switch (name) {
				case "auto":        return Value::create(VALUE_AUTO);
				case "default":     return Value::create(VALUE_DEFAULT);
				case "help":        return Value::create(VALUE_HELP);
				case "pointer":     return Value::create(VALUE_POINTER);
				case "progress":    return Value::create(VALUE_PROGRESS);
				case "wait":        return Value::create(VALUE_WAIT);
				case "text":        return Value::create(VALUE_TEXT);
				case "move":        return Value::create(VALUE_MOVE);
				case "not-allowed": return Value::create(VALUE_NOT_ALLOWED);
				case "zoom-in":     return Value::create(VALUE_ZOOM_IN);
				case "zoom-out":    return Value::create(VALUE_ZOOM_OUT);
			}
		}
		else if (par.type == TOKEN_URL) {
			consume_whitespace(par);
			if (next_token(par) == TOKEN_NUMBER) {
				consume_whitespace(par);
				if (next_token(par) != TOKEN_NUMBER) {
					back_token(par);
				}
			}
			else {
				back_token(par);
			}
		}
		else {
			throw error("invalid cursor value");
		}
		consume_whitespace(par);
	}
	while (next_token(par) == TOKEN_COMMA);

	if (par.type != TOKEN_EOF) {
		throw error("expected EOF");
	}
	throw error("invalid cursor value");
}

function @add_handler(name: String, type: Integer, handler, multiple: Boolean)
{
	property_data[] = {
		.name: name,
		.type: type,
		.handler: handler,
		.multiple: multiple
	};
	property_hash[name] = property_data.last;
}

function @init_static_data()
{
	property_hash = {};
	property_data = [];

	add_handler("all", PROP_ALL, parse_all#1, false);

	add_handler("color", PROP_COLOR, parse_color#1, false);

	add_handler("background-color", PROP_BACKGROUND_COLOR, parse_color#1, false);
	add_handler("background-image", PROP_BACKGROUND_IMAGE, parse_background_image#1, true);
	add_handler("background-repeat", PROP_BACKGROUND_REPEAT, parse_background_repeat#1, true);
	add_handler("background-attachment", PROP_BACKGROUND_ATTACHMENT, parse_background_attachment#1, true);
	add_handler("background-position", PROP_BACKGROUND_POSITION, parse_background_position#1, true);
	add_handler("background-clip", PROP_BACKGROUND_CLIP, parse_background_clip#1, true);
	add_handler("background-origin", PROP_BACKGROUND_ORIGIN, parse_background_clip#1, true);
	add_handler("background-size", PROP_BACKGROUND_SIZE, parse_background_size#1, true);
	add_handler("background", PROP_BACKGROUND, parse_background#1, false);

	add_handler("border-top-color", PROP_BORDER_TOP_COLOR, parse_color#1, false);
	add_handler("border-right-color", PROP_BORDER_RIGHT_COLOR, parse_color#1, false);
	add_handler("border-bottom-color", PROP_BORDER_BOTTOM_COLOR, parse_color#1, false);
	add_handler("border-left-color", PROP_BORDER_LEFT_COLOR, parse_color#1, false);
	add_handler("border-color", PROP_BORDER_COLOR, parse_border_color#1, false);

	add_handler("border-top-style", PROP_BORDER_TOP_STYLE, parse_border_style_value#1, false);
	add_handler("border-right-style", PROP_BORDER_RIGHT_STYLE, parse_border_style_value#1, false);
	add_handler("border-bottom-style", PROP_BORDER_BOTTOM_STYLE, parse_border_style_value#1, false);
	add_handler("border-left-style", PROP_BORDER_LEFT_STYLE, parse_border_style_value#1, false);
	add_handler("border-style", PROP_BORDER_STYLE, parse_border_style#1, false);

	add_handler("border-top-width", PROP_BORDER_TOP_WIDTH, parse_border_width_value#1, false);
	add_handler("border-right-width", PROP_BORDER_RIGHT_WIDTH, parse_border_width_value#1, false);
	add_handler("border-bottom-width", PROP_BORDER_BOTTOM_WIDTH, parse_border_width_value#1, false);
	add_handler("border-left-width", PROP_BORDER_LEFT_WIDTH, parse_border_width_value#1, false);
	add_handler("border-width", PROP_BORDER_WIDTH, parse_border_width#1, false);

	add_handler("border-top", PROP_BORDER_TOP, parse_border#1, false);
	add_handler("border-right", PROP_BORDER_RIGHT, parse_border#1, false);
	add_handler("border-bottom", PROP_BORDER_BOTTOM, parse_border#1, false);
	add_handler("border-left", PROP_BORDER_LEFT, parse_border#1, false);
	add_handler("border", PROP_BORDER, parse_border#1, false);

	add_handler("border-top-left-radius", PROP_BORDER_TOP_LEFT_RADIUS, parse_border_radius_value#1, false);
	add_handler("border-top-right-radius", PROP_BORDER_TOP_RIGHT_RADIUS, parse_border_radius_value#1, false);
	add_handler("border-bottom-right-radius", PROP_BORDER_BOTTOM_RIGHT_RADIUS, parse_border_radius_value#1, false);
	add_handler("border-bottom-left-radius", PROP_BORDER_BOTTOM_LEFT_RADIUS, parse_border_radius_value#1, false);
	add_handler("border-radius", PROP_BORDER, parse_border_radius#1, false);

	add_handler("border-collapse", PROP_BORDER_COLLAPSE, parse_border_collapse#1, false);
	add_handler("border-spacing", PROP_BORDER_SPACING, parse_border_spacing#1, false);

	// TODO: border images

	add_handler("box-shadow", PROP_BOX_SHADOW, parse_box_shadow#1, false);
	add_handler("text-shadow", PROP_TEXT_SHADOW, parse_text_shadow#1, false);
	add_handler("opacity", PROP_OPACITY, parse_opacity#1, false);

	add_handler("font-family", PROP_FONT_FAMILY, parse_font_family#1, true);
	add_handler("font-weight", PROP_FONT_WEIGHT, parse_font_weight#1, false);
	// TODO: font-stretch
	add_handler("font-style", PROP_FONT_STYLE, parse_font_style#1, false);
	add_handler("font-size", PROP_FONT_SIZE, parse_font_size#1, false);
	// TODO: font-size-adjust
	add_handler("font", PROP_FONT, parse_font#1, false);

	add_handler("line-height", PROP_LINE_HEIGHT, parse_line_height#1, false);

	add_handler("margin-top", PROP_MARGIN_TOP, parse_margin_value#1, false);
	add_handler("margin-right", PROP_MARGIN_RIGHT, parse_margin_value#1, false);
	add_handler("margin-bottom", PROP_MARGIN_BOTTOM, parse_margin_value#1, false);
	add_handler("margin-left", PROP_MARGIN_LEFT, parse_margin_value#1, false);
	add_handler("margin", PROP_MARGIN, parse_margin#1, false);

	add_handler("padding-top", PROP_PADDING_TOP, parse_padding_value#1, false);
	add_handler("padding-right", PROP_PADDING_RIGHT, parse_padding_value#1, false);
	add_handler("padding-bottom", PROP_PADDING_BOTTOM, parse_padding_value#1, false);
	add_handler("padding-left", PROP_PADDING_LEFT, parse_padding_value#1, false);
	add_handler("padding", PROP_PADDING, parse_padding#1, false);

	add_handler("display", PROP_DISPLAY, parse_display#1, false);
	add_handler("position", PROP_POSITION, parse_position#1, false);
	add_handler("top", PROP_TOP, parse_box_offset#1, false);
	add_handler("right", PROP_RIGHT, parse_box_offset#1, false);
	add_handler("bottom", PROP_BOTTOM, parse_box_offset#1, false);
	add_handler("left", PROP_LEFT, parse_box_offset#1, false);
	add_handler("float", PROP_FLOAT, parse_float#1, false);
	add_handler("clear", PROP_CLEAR, parse_clear#1, false);
	add_handler("z-index", PROP_Z_INDEX, parse_z_index#1, false);

	add_handler("width", PROP_WIDTH, parse_width_height#1, false);
	add_handler("height", PROP_HEIGHT, parse_width_height#1, false);
	add_handler("min-width", PROP_MIN_WIDTH, parse_length_percentage#1, false);
	add_handler("max-width", PROP_MAX_WIDTH, parse_max_width_height#1, false);
	add_handler("min-height", PROP_MIN_HEIGHT, parse_length_percentage#1, false);
	add_handler("max-height", PROP_MAX_HEIGHT, parse_max_width_height#1, false);
	add_handler("vertical-align", PROP_VERTICAL_ALIGN, parse_vertical_align#1, false);
	add_handler("box-sizing", PROP_BOX_SIZING, parse_box_sizing#1, false);

	add_handler("text-align", PROP_TEXT_ALIGN, parse_text_align#1, false);
	add_handler("text-indent", PROP_TEXT_INDENT, parse_length_percentage#1, false);
	add_handler("text-decoration", PROP_TEXT_DECORATION, parse_text_decoration#1, false);
	add_handler("letter-spacing", PROP_LETTER_SPACING, parse_letter_word_spacing#1, false);
	add_handler("word-spacing", PROP_WORD_SPACING, parse_letter_word_spacing#1, false);
	add_handler("text-transform", PROP_TEXT_TRANSFORM, parse_text_transform#1, false);
	add_handler("white-space", PROP_WHITE_SPACE, parse_white_space#1, false);

	add_handler("overflow", PROP_OVERFLOW, parse_overflow#1, false);
	add_handler("overflow-x", PROP_OVERFLOW_X, parse_overflow#1, false);
	add_handler("overflow-y", PROP_OVERFLOW_Y, parse_overflow#1, false);
	add_handler("clip", PROP_CLIP, parse_clip#1, false);
	add_handler("visibility", PROP_VISIBILITY, parse_visibility#1, false);

	add_handler("list-style-type", PROP_LIST_STYLE_TYPE, parse_list_style_type#1, false);
	add_handler("list-style-image", PROP_LIST_STYLE_IMAGE, parse_list_style_image#1, false);
	add_handler("list-style-position", PROP_LIST_STYLE_POSITION, parse_list_style_position#1, false);
	add_handler("list-style", PROP_LIST_STYLE, parse_list_style#1, false);

	add_handler("content", PROP_CONTENT, parse_content#1, false);

	add_handler("flex-direction", PROP_FLEX_DIRECTION, parse_flex_direction#1, false);
	add_handler("flex-wrap", PROP_FLEX_WRAP, parse_flex_wrap#1, false);
	add_handler("flex-flow", PROP_FLEX_FLOW, parse_flex_flow#1, false);
	add_handler("order", PROP_ORDER, parse_order#1, false);
	add_handler("flex-grow", PROP_FLEX_GROW, parse_flex_grow_shrink#1, false);
	add_handler("flex-shrink", PROP_FLEX_SHRINK, parse_flex_grow_shrink#1, false);
	add_handler("flex-basis", PROP_FLEX_BASIS, parse_flex_basis#1, false);
	add_handler("flex", PROP_FLEX, parse_flex#1, false);
	add_handler("justify-content", PROP_JUSTIFY_CONTENT, parse_justify_content#1, false);
	add_handler("align-items", PROP_ALIGN_ITEMS, parse_align_items#1, false);
	add_handler("align-self", PROP_ALIGN_SELF, parse_align_self#1, false);
	add_handler("align-content", PROP_ALIGN_CONTENT, parse_align_content#1, false);

	add_handler("tab-size", PROP_TAB_SIZE, parse_tab_size#1, false);
	add_handler("-moz-tab-size", PROP_TAB_SIZE, parse_tab_size#1, false);

	add_handler("cursor", PROP_CURSOR, parse_cursor#1, false);

	colors = {};

	colors["black"] = 0x000000;
	colors["silver"] = 0xC0C0C0;
	colors["gray"] = 0x808080;
	colors["white"] = 0xFFFFFF;
	colors["maroon"] = 0x800000;
	colors["red"] = 0xFF0000;
	colors["purple"] = 0x800080;
	colors["fuchsia"] = 0xFF00FF;
	colors["green"] = 0x008000;
	colors["lime"] = 0x00FF00;
	colors["olive"] = 0x808000;
	colors["yellow"] = 0xFFFF00;
	colors["navy"] = 0x000080;
	colors["blue"] = 0x0000FF;
	colors["teal"] = 0x008080;
	colors["aqua"] = 0x00FFFF;

	colors["aliceblue"] = 0xf0f8ff;
	colors["antiquewhite"] = 0xfaebd7;
	colors["aqua"] = 0x00ffff;
	colors["aquamarine"] = 0x7fffd4;
	colors["azure"] = 0xf0ffff;
	colors["beige"] = 0xf5f5dc;
	colors["bisque"] = 0xffe4c4;
	colors["black"] = 0x000000;
	colors["blanchedalmond"] = 0xffebcd;
	colors["blue"] = 0x0000ff;
	colors["blueviolet"] = 0x8a2be2;
	colors["brown"] = 0xa52a2a;
	colors["burlywood"] = 0xdeb887;
	colors["cadetblue"] = 0x5f9ea0;
	colors["chartreuse"] = 0x7fff00;
	colors["chocolate"] = 0xd2691e;
	colors["coral"] = 0xff7f50;
	colors["cornflowerblue"] = 0x6495ed;
	colors["cornsilk"] = 0xfff8dc;
	colors["crimson"] = 0xdc143c;
	colors["cyan"] = 0x00ffff;
	colors["darkblue"] = 0x00008b;
	colors["darkcyan"] = 0x008b8b;
	colors["darkgoldenrod"] = 0xb8860b;
	colors["darkgray"] = 0xa9a9a9;
	colors["darkgreen"] = 0x006400;
	colors["darkgrey"] = 0xa9a9a9;
	colors["darkkhaki"] = 0xbdb76b;
	colors["darkmagenta"] = 0x8b008b;
	colors["darkolivegreen"] = 0x556b2f;
	colors["darkorange"] = 0xff8c00;
	colors["darkorchid"] = 0x9932cc;
	colors["darkred"] = 0x8b0000;
	colors["darksalmon"] = 0xe9967a;
	colors["darkseagreen"] = 0x8fbc8f;
	colors["darkslateblue"] = 0x483d8b;
	colors["darkslategray"] = 0x2f4f4f;
	colors["darkslategrey"] = 0x2f4f4f;
	colors["darkturquoise"] = 0x00ced1;
	colors["darkviolet"] = 0x9400d3;
	colors["deeppink"] = 0xff1493;
	colors["deepskyblue"] = 0x00bfff;
	colors["dimgray"] = 0x696969;
	colors["dimgrey"] = 0x696969;
	colors["dodgerblue"] = 0x1e90ff;
	colors["firebrick"] = 0xb22222;
	colors["floralwhite"] = 0xfffaf0;
	colors["forestgreen"] = 0x228b22;
	colors["fuchsia"] = 0xff00ff;
	colors["gainsboro"] = 0xdcdcdc;
	colors["ghostwhite"] = 0xf8f8ff;
	colors["gold"] = 0xffd700;
	colors["goldenrod"] = 0xdaa520;
	colors["gray"] = 0x808080;
	colors["green"] = 0x008000;
	colors["greenyellow"] = 0xadff2f;
	colors["grey"] = 0x808080;
	colors["honeydew"] = 0xf0fff0;
	colors["hotpink"] = 0xff69b4;
	colors["indianred"] = 0xcd5c5c;
	colors["indigo"] = 0x4b0082;
	colors["ivory"] = 0xfffff0;
	colors["khaki"] = 0xf0e68c;
	colors["lavender"] = 0xe6e6fa;
	colors["lavenderblush"] = 0xfff0f5;
	colors["lawngreen"] = 0x7cfc00;
	colors["lemonchiffon"] = 0xfffacd;
	colors["lightblue"] = 0xadd8e6;
	colors["lightcoral"] = 0xf08080;
	colors["lightcyan"] = 0xe0ffff;
	colors["lightgoldenrodyellow"] = 0xfafad2;
	colors["lightgray"] = 0xd3d3d3;
	colors["lightgreen"] = 0x90ee90;
	colors["lightgrey"] = 0xd3d3d3;
	colors["lightpink"] = 0xffb6c1;
	colors["lightsalmon"] = 0xffa07a;
	colors["lightseagreen"] = 0x20b2aa;
	colors["lightskyblue"] = 0x87cefa;
	colors["lightslategray"] = 0x778899;
	colors["lightslategrey"] = 0x778899;
	colors["lightsteelblue"] = 0xb0c4de;
	colors["lightyellow"] = 0xffffe0;
	colors["lime"] = 0x00ff00;
	colors["limegreen"] = 0x32cd32;
	colors["linen"] = 0xfaf0e6;
	colors["magenta"] = 0xff00ff;
	colors["maroon"] = 0x800000;
	colors["mediumaquamarine"] = 0x66cdaa;
	colors["mediumblue"] = 0x0000cd;
	colors["mediumorchid"] = 0xba55d3;
	colors["mediumpurple"] = 0x9370db;
	colors["mediumseagreen"] = 0x3cb371;
	colors["mediumslateblue"] = 0x7b68ee;
	colors["mediumspringgreen"] = 0x00fa9a;
	colors["mediumturquoise"] = 0x48d1cc;
	colors["mediumvioletred"] = 0xc71585;
	colors["midnightblue"] = 0x191970;
	colors["mintcream"] = 0xf5fffa;
	colors["mistyrose"] = 0xffe4e1;
	colors["moccasin"] = 0xffe4b5;
	colors["navajowhite"] = 0xffdead;
	colors["navy"] = 0x000080;
	colors["oldlace"] = 0xfdf5e6;
	colors["olive"] = 0x808000;
	colors["olivedrab"] = 0x6b8e23;
	colors["orange"] = 0xffa500;
	colors["orangered"] = 0xff4500;
	colors["orchid"] = 0xda70d6;
	colors["palegoldenrod"] = 0xeee8aa;
	colors["palegreen"] = 0x98fb98;
	colors["paleturquoise"] = 0xafeeee;
	colors["palevioletred"] = 0xdb7093;
	colors["papayawhip"] = 0xffefd5;
	colors["peachpuff"] = 0xffdab9;
	colors["peru"] = 0xcd853f;
	colors["pink"] = 0xffc0cb;
	colors["plum"] = 0xdda0dd;
	colors["powderblue"] = 0xb0e0e6;
	colors["purple"] = 0x800080;
	colors["red"] = 0xff0000;
	colors["rosybrown"] = 0xbc8f8f;
	colors["royalblue"] = 0x4169e1;
	colors["saddlebrown"] = 0x8b4513;
	colors["salmon"] = 0xfa8072;
	colors["sandybrown"] = 0xf4a460;
	colors["seagreen"] = 0x2e8b57;
	colors["seashell"] = 0xfff5ee;
	colors["sienna"] = 0xa0522d;
	colors["silver"] = 0xc0c0c0;
	colors["skyblue"] = 0x87ceeb;
	colors["slateblue"] = 0x6a5acd;
	colors["slategray"] = 0x708090;
	colors["slategrey"] = 0x708090;
	colors["snow"] = 0xfffafa;
	colors["springgreen"] = 0x00ff7f;
	colors["steelblue"] = 0x4682b4;
	colors["tan"] = 0xd2b48c;
	colors["teal"] = 0x008080;
	colors["thistle"] = 0xd8bfd8;
	colors["tomato"] = 0xff6347;
	colors["turquoise"] = 0x40e0d0;
	colors["violet"] = 0xee82ee;
	colors["wheat"] = 0xf5deb3;
	colors["white"] = 0xffffff;
	colors["whitesmoke"] = 0xf5f5f5;
	colors["yellow"] = 0xffff00;
	colors["yellowgreen"] = 0x9acd32;
}
