/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "classes";

import "browser/css/selector";
import "browser/css/property";
import "browser/css/media_query";
import "browser/css/parser";
import "util/string";

const {
	RULE_SELECTOR,
	RULE_MEDIA_QUERY,
	RULE_IMPORT,
	RULE_SUPPORTS,
	RULE_PAGE,
	RULE_FONT_FACE,
	RULE_KEYFRAMES
};

class Stylesheet
{
	var rules: Rule[];

	constructor create()
	{
		rules = [];
	}

	function add_rule(rule: Rule)
	{
		rules[] = rule;
	}

	function to_string(): String
	{
		return to_string(0);
	}

	function @to_string(level: Integer): String
	{
		var s = {""};
		foreach (var rule in rules) {
			switch (rule.type) {
				case RULE_SELECTOR:    (rule as SelectorRule).to_string(s, level); break;
				case RULE_MEDIA_QUERY: (rule as MediaQueryRule).to_string(s, level); break;
				case RULE_IMPORT:      (rule as ImportRule).to_string(s, level); break;
				
				default:
					throw error("unknown rule type");
			}
		}
		return s;
	}
}

class Rule
{
	var type: Integer;

	constructor create(type: Integer)
	{
		this.type = type;
	}
}

class SelectorRule: Rule
{
	var selector: Selector[];
	var properties: Property[];

	constructor create(selector: Selector[], properties: Property[])
	{
		super::create(RULE_SELECTOR);
		this.selector = selector;
		this.properties = properties;
	}

	function @to_string(s: String, level: Integer)
	{
		indent(s, level);
		s += serialize_selector_group(selector);
		s += " {\n";
		foreach (var property in properties) {
			indent(s, level+1);
			s += property.to_string();
			s[] = '\n';
		}
		indent(s, level);
		s += "}\n\n";
	}
}

class MediaQueryRule: Rule
{
	var media_query: MediaQuery;
	var stylesheet: Stylesheet;

	constructor create(media_query: MediaQuery, stylesheet: Stylesheet)
	{
		super::create(RULE_MEDIA_QUERY);
		this.media_query = media_query;
		this.stylesheet = stylesheet;
	}

	function @to_string(s: String, level: Integer)
	{
		indent(s, level);
		s += "@media ";
		s += serialize_media_query(media_query);
		s += " {\n";
		s += stylesheet.to_string(level+1);
		indent(s, level);
		s += "}\n\n";
	}
}

class ImportRule: Rule
{
	var url: String;
	var media_query: MediaQuery;

	constructor create(url: String, media_query: MediaQuery)
	{
		super::create(RULE_IMPORT);
		this.url = url;
		this.media_query = media_query;
	}

	function @to_string(s: String, level: Integer)
	{
		indent(s, level);
		s += "@import ";
		s += css_serialize_string(url);
		if (media_query) {
			s[] = ' ';
			s += serialize_media_query(media_query);
		}
		s += ";\n\n";
	}
}

function @indent(s: String, level: Integer)
{
	for (var i=0; i<level; i++) {
		s[] = ' ';
		s[] = ' ';
		s[] = ' ';
		s[] = ' ';
	}
}
