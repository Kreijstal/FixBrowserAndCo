/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "classes";

import "io/charset/charset";
import "util/string";

struct Token
{
	var type: Integer;
	var value: Dynamic;
	var @_reserved0;
	var @_reserved1;
}

struct HashToken
{
	var @_reserved0;
	var @_reserved1;
	var type_id: Boolean;
	var @_reserved2;
}

struct DimensionToken
{
	var @_reserved0;
	var @_reserved1;
	var unit: String;
	var @_reserved2;
}

struct UnicodeRangeToken
{
	var @_reserved0;
	var @_reserved1;
	var start_char: Integer;
	var end_char: Integer;
}

class Parser
{
	var type: Integer;
	var value: Dynamic;
	var @_reserved0;
	var @_reserved1;
	var @buf: String;
	var @pos: Integer;
	var @again: Boolean;
	var tokens: [Token];

	function dump()
	{
		dump(0);
	}
	
	function dump(level: Integer)
	{
		rewind_buffer(this);
		while (next_token(this) != TOKEN_EOF) {
			dump_token(this as [Token], level);
		}
	}
}

class SimpleBlock: Parser
{
	var associated_token: Integer;
}

class Function: Parser
{
	var name: String;
}

class Declaration: Parser
{
	var name: String;
	var important: Boolean;
}

const {
	TOKEN_EOF,
	TOKEN_IDENT,
	@TOKEN_FUNCTION,
	TOKEN_AT_KEYWORD,
	TOKEN_HASH,
	TOKEN_STRING,
	TOKEN_BAD_STRING,
	TOKEN_URL,
	TOKEN_BAD_URL,
	TOKEN_DELIM,
	TOKEN_NUMBER,
	TOKEN_PERCENTAGE,
	TOKEN_DIMENSION,
	TOKEN_UNICODE_RANGE,
	TOKEN_INCLUDE_MATCH,
	TOKEN_DASH_MATCH,
	TOKEN_PREFIX_MATCH,
	TOKEN_SUFFIX_MATCH,
	TOKEN_SUBSTRING_MATCH,
	TOKEN_COLUMN,
	TOKEN_WHITESPACE,
	TOKEN_CDO,
	TOKEN_CDC,
	TOKEN_COLON,
	TOKEN_SEMICOLON,
	TOKEN_COMMA,
	TOKEN_SQUARE_LBRACKET,
	@TOKEN_SQUARE_RBRACKET,
	TOKEN_LBRACKET,
	@TOKEN_RBRACKET,
	TOKEN_CURLY_LBRACKET,
	@TOKEN_CURLY_RBRACKET,

	COMPONENT_SIMPLE_BLOCK,
	COMPONENT_FUNCTION,
	COMPONENT_RULE,
	COMPONENT_DECLARATION
};

class Rule
{
	var prelude: Parser;
	var name: String;
	var value: SimpleBlock;
}

class Number
{
	var repr: String;
	var value: Dynamic;
	var is_number: Boolean;

	constructor create(repr: String, value: Dynamic, is_number: Boolean)
	{
		this.repr = repr;
		this.value = value;
		this.is_number = is_number;
	}

	function as_float(): Float
	{
		return is_number? (value as Float) : float(value as Integer);
	}
}

class ANB
{
	var step: Integer;
	var offset: Integer;

	constructor create(step: Integer, offset: Integer)
	{
		this.step = step;
		this.offset = offset;
	}
}

function @get_buf(buf: String, off: Integer): Integer
{
	if (off < buf.length) {
		return buf[off];
	}
	return 0;
}

function @create_buffer(): Parser
{
	var par = new Parser;
	par.tokens = [];
	return par;
}

function rewind_buffer(par: Parser)
{
	par.pos = 0;
	par.again = false;
}

function @add_token(buf: Parser, token: [Token])
{
	var tokens = buf.tokens;
	var len = length(tokens);
	(tokens as Dynamic[]).set_length(len + Token::SIZE);
	Array::copy(tokens as Dynamic[], len, token as Dynamic[], 0, Token::SIZE);
}

function @clone_token(token: [Token]): [Token]
{
	return (token as Dynamic[]).extract(0, Token::SIZE);
}

function @get_token_count(buf: Parser): Integer
{
	return buf.tokens.length;
}

function @get_token_idx(idx: Integer): Integer
{
	return idx * Token::SIZE;
}

function @token_type_to_string(type: Integer): String
{
	switch (type) {
		case TOKEN_IDENT:            return "ident";
		case TOKEN_FUNCTION:         return "function";
		case TOKEN_AT_KEYWORD:       return "at_keyword";
		case TOKEN_HASH:             return "hash";
		case TOKEN_STRING:           return "string";
		case TOKEN_BAD_STRING:       return "bad_string";
		case TOKEN_URL:              return "url";
		case TOKEN_BAD_URL:          return "bad_url";
		case TOKEN_DELIM:            return "delim";
		case TOKEN_NUMBER:           return "number";
		case TOKEN_PERCENTAGE:       return "percentage";
		case TOKEN_DIMENSION:        return "dimension";
		case TOKEN_UNICODE_RANGE:    return "unicode_range";
		case TOKEN_INCLUDE_MATCH:    return "include_match";
		case TOKEN_DASH_MATCH:       return "dash_match";
		case TOKEN_PREFIX_MATCH:     return "prefix_match";
		case TOKEN_SUFFIX_MATCH:     return "suffix_match";
		case TOKEN_SUBSTRING_MATCH:  return "substring_match";
		case TOKEN_COLUMN:           return "column";
		case TOKEN_WHITESPACE:       return "whitespace";
		case TOKEN_CDO:              return "'<!--'";
		case TOKEN_CDC:              return "'-->'";
		case TOKEN_COLON:            return "':'";
		case TOKEN_SEMICOLON:        return "';'";
		case TOKEN_COMMA:            return "','";
		case TOKEN_SQUARE_LBRACKET:  return "'['";
		case TOKEN_SQUARE_RBRACKET:  return "']'";
		case TOKEN_LBRACKET:         return "'('";
		case TOKEN_RBRACKET:         return "')'";
		case TOKEN_CURLY_LBRACKET:   return "'{'";
		case TOKEN_CURLY_RBRACKET:   return "'}'";

		case COMPONENT_SIMPLE_BLOCK: return "SimpleBlock";
		case COMPONENT_FUNCTION:     return "Function";
		case COMPONENT_RULE:         return "Rule";
		case COMPONENT_DECLARATION:  return "Declaration";
	}

	return {type};
}

function dump_token(token: [Token], level: Integer)
{
	var s = {""};
	for (var i=0; i<level; i++) {
		s[] = ' ';
		s[] = ' ';
	}

	s += "token type="+token_type_to_string(token[0 as Token].type);

	switch (token[0 as Token].type) {
		case TOKEN_IDENT:
		case TOKEN_FUNCTION:
		case TOKEN_AT_KEYWORD:
		case TOKEN_HASH:
		case TOKEN_STRING:
		case TOKEN_BAD_STRING:
		case TOKEN_URL:
		case TOKEN_BAD_URL:
			s += " value='"+token[0 as Token].value+"'";
			break;

		case TOKEN_NUMBER:
		case TOKEN_PERCENTAGE:
			s += " value="+(token[0 as Token].value as Number);
			break;

		case TOKEN_DELIM:
			s += " value='"+String::char(token[0 as Token].value)+"'";
			break;
	}

	switch (token[0 as Token].type) {
		case TOKEN_HASH:
			s += " type_id="+((token as [HashToken])[0 as HashToken].type_id? "true":"false");
			break;

		case TOKEN_UNICODE_RANGE: {
			var unicode_token = token as [UnicodeRangeToken];
			s += " from=0x"+String::from_hex_int(unicode_token[0 as UnicodeRangeToken].start_char).pad_left(4, '0')+" to=0x"+String::from_hex_int(unicode_token[0 as UnicodeRangeToken].end_char).pad_left(4, '0');
			break;
		}

		case TOKEN_DIMENSION: {
			var dimension_token = token as [DimensionToken];
			s += " value="+(token[0 as Token].value as Number)+" unit='"+dimension_token[0 as DimensionToken].unit+"'";
			break;
		}

		case COMPONENT_SIMPLE_BLOCK: {
			var simple_block = token[0 as Token].value as SimpleBlock;
			s += " associated_token="+token_type_to_string(simple_block.associated_token);
			break;
		}

		case COMPONENT_FUNCTION: {
			var func = token[0 as Token].value as Function;
			s += " name='"+func.name+"'";
			break;
		}

		case COMPONENT_DECLARATION: {
			var decl = token[0 as Token].value as Declaration;
			s += " name='"+decl.name+"'";
			break;
		}
	}

	log(s);

	var type = token[0 as Token].type;
	if (type == COMPONENT_SIMPLE_BLOCK || type == COMPONENT_FUNCTION || type == COMPONENT_DECLARATION) {
		var block = token[0 as Token].value as Parser;
		block.dump(level+1);
	}
	if (type == COMPONENT_RULE) {
		dump_rule(token[0 as Token].value, level+1);
	}
}

function next_token(par: Parser): Integer
{
	if (par.again) {
		par.again = false;
		return par.type;
	}
	var tokens = par.tokens;
	if (tokens) {
		var pos = par.pos;
		if (pos < length(tokens)) {
			Array::copy(par as Dynamic[], 0, tokens as Dynamic[], pos, Token::SIZE);
			par.pos = pos + Token::SIZE;
		}
		else {
			par.type = TOKEN_EOF;
		}
	}
	else {
		par.type = consume_token(par);
	}
	return par.type;
}

function back_token(par: Parser)
{
	par.again = true;
}

function @consume_token(par: Parser): Integer
{
	var buf = par.buf;
	var pos = par.pos;
	if (pos == buf.length) return TOKEN_EOF;

	var c = buf[pos++];

	while (c == '/' && pos < buf.length && buf[pos] == '*') {
		pos++;
		while (pos < buf.length) {
			c = buf[pos++];
			if (c == '*' && pos < buf.length && buf[pos] == '/') {
				pos++;
				break;
			}
		}
		if (pos == buf.length) {
			par.pos = pos;
			return TOKEN_EOF;
		}
		c = buf[pos++];
	}
	
	switch (c) {
		case '\n', '\t', ' ':
			while (pos < buf.length) {
				switch (buf[pos]) {
					case '\n', '\t', ' ':
						pos++;
						continue;
				}
				break;
			}
			par.pos = pos;
			return TOKEN_WHITESPACE;

		case '"':
			par.pos = pos;
			return consume_string_token(par, '"');

		case '#':
			(par as [HashToken])[0 as HashToken].type_id = false;
			if (pos < buf.length) {
				var c2 = buf[pos];
				if (is_name_code_char(c2) || (pos+1 < buf.length && starts_with_valid_escape(c2, buf[pos+1]))) {
					if (starts_identifier(c2, get_buf(buf, pos+1), get_buf(buf, pos+2))) {
						(par as [HashToken])[0 as HashToken].type_id = true;
					}
					par.pos = pos;
					par.value = consume_name(par);
					return TOKEN_HASH;
				}
			}
			break;

		case '$':
			if (pos < buf.length && buf[pos] == '=') {
				pos++;
				par.pos = pos;
				return TOKEN_SUFFIX_MATCH;
			}
			break;

		case '\'':
			par.pos = pos;
			return consume_string_token(par, '\'');

		case '(':
			par.pos = pos;
			return TOKEN_LBRACKET;

		case ')':
			par.pos = pos;
			return TOKEN_RBRACKET;

		case '*':
			if (pos < buf.length && buf[pos] == '=') {
				pos++;
				par.pos = pos;
				return TOKEN_SUBSTRING_MATCH;
			}
			break;

		case '+':
			if (starts_number(c, get_buf(buf, pos), get_buf(buf, pos+1))) {
				pos--;
				par.pos = pos;
				return consume_numeric_token(par);
			}
			break;

		case ',':
			par.pos = pos;
			return TOKEN_COMMA;

		case '-': {
			var c2 = get_buf(buf, pos);
			var c3 = get_buf(buf, pos+1);
			if (starts_number(c, c2, c3)) {
				pos--;
				par.pos = pos;
				return consume_numeric_token(par);
			}
			if (starts_identifier(c, c2, c3)) {
				pos--;
				par.pos = pos;
				return consume_ident_like_token(par);
			}
			if (c2 == '-' && c3 == '>') {
				pos += 2;
				par.pos = pos;
				return TOKEN_CDC;
			}
			break;
		}

		case '.': {
			var c2 = get_buf(buf, pos);
			var c3 = get_buf(buf, pos+1);
			if (starts_number(c, c2, c3)) {
				pos--;
				par.pos = pos;
				return consume_numeric_token(par);
			}
			break;
		}

		case ':':
			par.pos = pos;
			return TOKEN_COLON;

		case ';':
			par.pos = pos;
			return TOKEN_SEMICOLON;

		case '<':
			if (pos+2 < buf.length && buf[pos] == '!' && buf[pos+1] == '-' && buf[pos+2] == '-') {
				pos += 3;
				par.pos = pos;
				return TOKEN_CDO;
			}
			break;

		case '@': {
			var c2 = get_buf(buf, pos);
			var c3 = get_buf(buf, pos+1);
			var c4 = get_buf(buf, pos+2);
			if (starts_identifier(c2, c3, c4)) {
				par.pos = pos;
				par.value = consume_name(par);
				return TOKEN_AT_KEYWORD;
			}
			break;
		}

		case '[':
			par.pos = pos;
			return TOKEN_SQUARE_LBRACKET;

		case '\\':
			if (starts_with_valid_escape(c, get_buf(buf, pos))) {
				pos--;
				par.pos = pos;
				return consume_ident_like_token(par);
			}
			break;

		case ']':
			par.pos = pos;
			return TOKEN_SQUARE_RBRACKET;

		case '^':
			if (pos < buf.length && buf[pos] == '=') {
				pos++;
				par.pos = pos;
				return TOKEN_PREFIX_MATCH;
			}
			break;

		case '{':
			par.pos = pos;
			return TOKEN_CURLY_LBRACKET;

		case '}':
			par.pos = pos;
			return TOKEN_CURLY_RBRACKET;

		case '0'..'9':
			pos--;
			par.pos = pos;
			return consume_numeric_token(par);

		case 'u', 'U': {
			var c2 = get_buf(buf, pos);
			if (c2 == '+') {
				var c3 = get_buf(buf, pos+1);
				if (is_hex_digit(c3) || c3 == '?') {
					pos++;
					par.pos = pos;
					return consume_unicode_range_token(par);
				}
			}

			pos--;
			par.pos = pos;
			return consume_ident_like_token(par);
		}

		case 'A'..'T', 'V'..'Z', 'a'..'t', 'v'..'z', 0x80..0x7FFFFFFF, '_':
			pos--;
			par.pos = pos;
			return consume_ident_like_token(par);

		case '|':
			if (pos < length(buf)) {
				var c2 = buf[pos];
				if (c2 == '=') {
					pos++;
					par.pos = pos;
					return TOKEN_DASH_MATCH;
				}
				if (c2 == '|') {
					pos++;
					par.pos = pos;
					return TOKEN_COLUMN;
				}
			}
			break;

		case '~':
			if (pos < buf.length && buf[pos] == '=') {
				pos++;
				par.pos = pos;
				return TOKEN_INCLUDE_MATCH;
			}
			break;
	}

	par.value = c;
	par.pos = pos;
	return TOKEN_DELIM;
}

function @consume_string_token(par: Parser, end_char: Integer): Integer
{
	var buf = par.buf;
	var pos = par.pos;

	var value = par.value = {""};

	for (;;) {
		if (pos == buf.length) {
			par.pos = pos;
			return TOKEN_STRING;
		}

		var c = buf[pos++];
		if (c == end_char) {
			par.pos = pos;
			return TOKEN_STRING;
		}
		
		switch (c) {
			case '\n':
				par.pos = pos - 1;
				return TOKEN_BAD_STRING;

			case '\\': {
				if (pos == buf.length) continue;
				var c2 = buf[pos];
				if (c2 == '\n') {
					pos++;
					continue;
				}
				if (starts_with_valid_escape(c, c2)) {
					par.pos = pos;
					value[] = consume_escaped_char(par);
					pos = par.pos;
				}
				continue;
			}
			
			default:
				value[] = c;
				continue;
		}
	}
}

function @starts_with_valid_escape(c1: Integer, c2: Integer): Boolean
{
	if (c1 != '\\') return false;
	if (c2 == '\n') return false;
	return true;
}

function @consume_escaped_char(par: Parser): Integer
{
	var buf = par.buf;
	var pos = par.pos;

	for (;;) {
		if (pos == buf.length) {
			par.pos = pos;
			return 0xFFFD;
		}
		
		var c = buf[pos++];
		switch (c) {
			case '0'..'9':
			case 'a'..'f':
			case 'A'..'F': {
				var value = 0;
				for (var i=0; i<6; i++) {
					var ok = true;
					switch (c) {
						case '0'..'9': value = value*16 + (c - '0'); break;
						case 'a'..'f': value = value*16 + (c - 'a' + 10); break;
						case 'A'..'F': value = value*16 + (c - 'A' + 10); break;
						default: ok = false; pos--;
					}
					if (!ok || pos == buf.length-1) break;
					c = buf[pos++];
				}
				if (pos < buf.length && is_whitespace(buf[pos])) {
					pos++;
				}
				if (value == 0 || (value >= 0xD800 && value <= 0xDFFF) || value > 0x10FFFF) {
					value = 0xFFFD;
				}
				par.pos = pos;
				return value;
			}

			default:
				par.pos = pos;
				return c;
		}
	}
}

function @consume_numeric_token(par: Parser): Integer
{
	par.value = consume_number(par);

	var buf = par.buf;
	var pos = par.pos;

	var c = get_buf(buf, pos);

	if (starts_identifier(c, get_buf(buf, pos+1), get_buf(buf, pos+2))) {
		(par as [DimensionToken])[0 as DimensionToken].unit = consume_name(par);
		return TOKEN_DIMENSION;
	}

	if (c == '%') {
		pos++;
		par.pos = pos;
		return TOKEN_PERCENTAGE;
	}

	return TOKEN_NUMBER;
}

function @consume_number(par: Parser): Number
{
	var buf = par.buf;
	var pos = par.pos;

	var repr = {""};
	var is_number = false;

	var c = buf[pos];
	if (c == '+' || c == '-') {
		repr[] = c;
		pos++;
	}
	
	while (pos < buf.length) {
		c = buf[pos];
		if (!is_digit(c)) break;
		repr[] = c;
		pos++;
	}

	if (pos+1 < length(buf) && buf[pos] == '.' && is_digit(buf[pos+1])) {
		repr[] = buf[pos++];
		repr[] = buf[pos++];
		is_number = true;
		while (pos < buf.length) {
			c = buf[pos];
			if (!is_digit(c)) break;
			repr[] = c;
			pos++;
		}
	}

	if (pos < buf.length && (buf[pos] == 'e' || buf[pos] == 'E')) {
		var has_sign_digit = (pos+2 < buf.length && (buf[pos+1] == '-' || buf[pos+1] == '+') && is_digit(buf[pos+2]));
		var has_digit = (pos+1 < buf.length && is_digit(buf[pos+1]));
		if (has_sign_digit || has_digit) {
			repr[] = buf[pos++];
			if (has_sign_digit) {
				repr[] = buf[pos++];
			}
			repr[] = buf[pos++];
			is_number = true;
			while (pos < buf.length) {
				c = buf[pos];
				if (!is_digit(c)) break;
				repr[] = c;
				pos++;
			}
		}
	}

	var value;
	if (!is_number) {
		var (r, e) = String::parse_int(repr);
		if (e) {
			is_number = true;
		}
		else {
			value = r;
		}
	}
	if (is_number) {
		value = String::parse_float(repr);
	}

	par.pos = pos;
	return Number::create(repr, value, is_number);
}

function @consume_ident_like_token(par: Parser): Integer
{
	var name = consume_name(par);

	var buf = par.buf;
	var pos = par.pos;

	var c = get_buf(buf, pos);
	if (c == '(') {
		pos++;
		if (name.length == 3 && name.to_lower_case() == "url") {
			par.pos = pos;
			return consume_url_token(par);
		}
		par.pos = pos;
		par.value = name;
		return TOKEN_FUNCTION;
	}
	
	par.value = name;
	return TOKEN_IDENT;
}

function @consume_url_token(par: Parser): Integer
{
	var buf = par.buf;
	var pos = par.pos;

	while (pos < buf.length) {
		var c = buf[pos];
		if (!is_whitespace(c)) break;
		pos++;
	}

	if (pos == buf.length) {
		return TOKEN_URL;
	}

	var c = buf[pos];
	if (c == '"' || c == '\'') {
		pos++;
		par.pos = pos;
		var token = consume_string_token(par, c);
		if (token == TOKEN_BAD_STRING) {
			consume_remnants_of_bad_url(par);
			return TOKEN_BAD_URL;
		}
		pos = par.pos;
		while (pos < buf.length) {
			c = buf[pos];
			if (!is_whitespace(c)) break;
			pos++;
		}
		if (pos == buf.length) {
			par.pos = pos;
			return TOKEN_URL;
		}
		if (buf[pos] == ')') {
			pos++;
			par.pos = pos;
			return TOKEN_URL;
		}
		par.pos = pos;
		consume_remnants_of_bad_url(par);
		return TOKEN_BAD_URL;
	}

	var value = {""};

	while (pos < buf.length) {
		c = buf[pos++];
		switch (c) {
			case ')':
				par.pos = pos;
				par.value = value;
				return TOKEN_URL;

			case '\n', '\t', ' ':
				while (pos < buf.length) {
					c = buf[pos];
					if (!is_whitespace(c)) break;
					pos++;
				}
				if (pos == buf.length) {
					par.pos = pos;
					par.value = value;
					return TOKEN_URL;
				}
				if (pos < buf.length && buf[pos] == ')') {
					pos++;
					par.pos = pos;
					par.value = value;
					return TOKEN_URL;
				}
				par.pos = pos;
				consume_remnants_of_bad_url(par);
				return TOKEN_BAD_URL;

			case '"', '\'', '(':
				par.pos = pos;
				consume_remnants_of_bad_url(par);
				return TOKEN_BAD_URL;

			case '\\':
				if (pos < buf.length && starts_with_valid_escape(c, buf[pos])) {
					par.pos = pos;
					value[] = consume_escaped_char(par);
					pos = par.pos;
					break;
				}
				par.pos = pos;
				consume_remnants_of_bad_url(par);
				return TOKEN_BAD_URL;

			default:
				value[] = c;
		}
	}

	par.pos = pos;
	par.value = value;
	return TOKEN_URL;
}

function @consume_remnants_of_bad_url(par: Parser)
{
	var buf = par.buf;
	var pos = par.pos;

	while (pos < buf.length) {
		var c = buf[pos++];
		if (c == ')') break;
		if (pos < buf.length && starts_with_valid_escape(c, buf[pos])) {
			par.pos = pos;
			consume_escaped_char(par);
			pos = par.pos;
		}
	}
}

function @interpret_hex_number(buf: String, start: Integer, end: Integer, replacement: Integer): Integer
{
	var value = 0;
	for (var i=start; i<end; i++) {
		var c = buf[i];
		if (c == '?') c = replacement;
		switch (c) {
			case '0'..'9': value = value*16 + (c - '0'); break;
			case 'a'..'f': value = value*16 + (c - 'a' + 10); break;
			case 'A'..'F': value = value*16 + (c - 'A' + 10); break;
		}
	}
	return value;
}

function @consume_unicode_range_token(par: Parser): Integer
{
	var buf = par.buf;
	var pos = par.pos;

	var start = pos;
	var cnt = 0;
	var question_marks = false;

	while (cnt < 6) {
		var c = buf[pos];
		if (!is_hex_digit(c)) break;
		pos++;
		cnt++;
	}

	while (cnt < 6) {
		var c = buf[pos];
		if (c != '?') break;
		pos++;
		cnt++;
		question_marks = true;
	}

	var unicode_token = par as [UnicodeRangeToken];

	if (question_marks) {
		unicode_token[0 as UnicodeRangeToken].start_char = interpret_hex_number(buf, start, pos, '0');
		unicode_token[0 as UnicodeRangeToken].end_char = interpret_hex_number(buf, start, pos, 'F');
		par.pos = pos;
		return TOKEN_UNICODE_RANGE;
	}

	unicode_token[0 as UnicodeRangeToken].start_char = interpret_hex_number(buf, start, pos, '?');

	if (pos+1 < buf.length && buf[pos] == '-' && is_hex_digit(buf[pos+1])) {
		pos++;
		start = pos;
		cnt = 0;
		while (cnt < 6) {
			var c = buf[pos];
			if (!is_hex_digit(c)) break;
			pos++;
			cnt++;
		}
		unicode_token[0 as UnicodeRangeToken].end_char = interpret_hex_number(buf, start, pos, '?');
	}
	else {
		unicode_token[0 as UnicodeRangeToken].end_char = unicode_token[0 as UnicodeRangeToken].start_char;
	}

	par.pos = pos;
	return TOKEN_UNICODE_RANGE;
}

function @starts_identifier(c1: Integer, c2: Integer, c3: Integer): Boolean
{
	if (is_name_start_code_char(c1)) {
		return true;
	}
	
	switch (c1) {
		case '-':
			return (is_name_start_code_char(c2) || starts_with_valid_escape(c2, c3) || c2 == '-');
			
		case '\\':
			return starts_with_valid_escape(c1, c2);
	}
	return false;
}

function @starts_number(c1: Integer, c2: Integer, c3: Integer): Boolean
{
	switch (c1) {
		case '+', '-':
			if (is_digit(c2)) return true;
			if (c2 == '.' && is_digit(c3)) return true;
			return false;
		
		case '.':
			if (is_digit(c2)) return true;
			return false;

		case '0'..'9':
			return true;
	}
	return false;
}

function @consume_name(par: Parser): String
{
	var buf = par.buf;
	var pos = par.pos;

	var result = {""};

	for (;;) {
		if (pos == buf.length) {
			par.pos = pos;
			return result;
		}

		var c = buf[pos++];
		if (is_name_code_char(c)) {
			result[] = c;
			continue;
		}

		if (pos < buf.length && starts_with_valid_escape(c, buf[pos])) {
			par.pos = pos;
			result[] = consume_escaped_char(par);
			pos = par.pos;
			continue;
		}

		par.pos = pos-1;
		return result;
	}
}

function @is_whitespace(c: Integer): Boolean
{
	switch (c) {
		case '\n', '\t', ' ': return true;
	}
	return false;
}

function @is_name_start_code_char(c: Integer): Boolean
{
	if (c >= 0x80) return true;
	switch (c) {
		case 'a'..'z', 'A'..'Z', '_':
			return true;
	}
	return false;
}

function @is_name_code_char(c: Integer): Boolean
{
	if (is_name_start_code_char(c)) return true;
	switch (c) {
		case '0'..'9', '-':
			return true;
	}
	return false;
}

function @is_digit(c: Integer): Boolean
{
	switch (c) {
		case '0'..'9': return true;
	}
	return false;
}

function @is_hex_digit(c: Integer): Boolean
{
	switch (c) {
		case '0'..'9': return true;
		case 'a'..'f': return true;
		case 'A'..'F': return true;
	}
	return false;
}

function parser_create(buf: String, charset: Charset): Parser
{
	var new_buf = {""};
	for (var i=0; i<buf.length; i++) {
		var c = buf[i];
		switch (c) {
			case '\r':
				if (i+1 < buf.length && buf[i+1] == '\n') {
					i++;
				}
			case 0x0C:
				new_buf[] = '\n';
				continue;

			default:
				new_buf[] = c;
				continue;
		}
	}

	charset.convert(new_buf);

	for (var i=0; i<buf.length; i++) {
		if (buf[i] == 0) {
			buf[i] = 0xFFFD;
		}
	}

	var par = new Parser;
	par.buf = new_buf;
	return par;
}

function parse_stylesheet(par: Parser): Rule[]
{
	return consume_list_of_rules(par, true);
}

function parse_list_of_rules(par: Parser): Rule[]
{
	return consume_list_of_rules(par, false);
}

function parse_rule(par: Parser): Rule
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_EOF) {
		throw error("syntax error");
	}
	
	var rule;
	if (token == TOKEN_AT_KEYWORD) {
		rule = consume_at_rule(par);
	}
	else {
		rule = consume_qualified_rule(par);
		if (!rule) {
			throw error("syntax error");
		}
	}

	token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_EOF) {
		return rule;
	}
	throw error("syntax error");
}

function parse_declaration(par: Parser): Declaration
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token != TOKEN_IDENT) {
		throw error("syntax error");
	}
	var decl = consume_declaration(par);
	if (!decl) {
		throw error("syntax error");
	}
	return decl;
}

function parse_list_of_declarations(par: Parser): Parser
{
	return consume_list_of_declarations(par);
}

function parse_component_value(par: Parser): [Token]
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_EOF) {
		throw error("syntax error");
	}

	back_token(par);
	var value = clone_token(consume_component_value(par) as [Token]);

	token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}

	if (token == TOKEN_EOF) {
		return value;
	}
	throw error("syntax error");
}

function parse_list_of_component_values(par: Parser): Parser
{
	var buf = create_buffer();
	for (;;) {
		var value = consume_component_value(par) as [Token];
		if (value[0 as Token].type == TOKEN_EOF) break;
		add_token(buf, value);
	}
	return buf;
}

function dump_rule(rule: Rule, level: Integer)
{
	var prefix = {""};
	for (var i=0; i<level; i++) {
		prefix[] = ' ';
		prefix[] = ' ';
	}
	if (rule.name) {
		log(prefix+"at-rule name='"+rule.name+"'");
	}
	else {
		log(prefix+"rule");
	}
	log(prefix+"  prelude:");
	rule.prelude.dump(level+2);
	if (rule.value) {
		log(prefix+"  block:");
		rule.value.dump(level+2);
	}
}

function dump_rule_list(rules: Rule[])
{
	log("num_rules="+rules.length);
	for (var i=0; i<rules.length; i++) {
		var rule = rules[i];
		dump_rule(rule, 0);
	}
}

function @consume_list_of_rules(par: Parser, toplevel: Boolean): Rule[]
{
	var rules: Rule[] = [];
	
	for (;;) {
		var token = next_token(par);
		switch (token) {
			case TOKEN_WHITESPACE:
				break;

			case TOKEN_EOF:
				return rules;

			case TOKEN_CDO, TOKEN_CDC:
				if (!toplevel) {
					back_token(par);
					var rule = consume_qualified_rule(par);
					if (rule) rules[] = rule;
				}
				break;

			case TOKEN_AT_KEYWORD: {
				back_token(par);
				var rule = consume_at_rule(par);
				if (rule) rules[] = rule;
				break;
			}

			default: {
				back_token(par);
				var rule = consume_qualified_rule(par);
				if (rule) rules[] = rule;
				break;
			}
		}
	}
}

function @consume_at_rule(par: Parser): Rule
{
	var rule = new Rule;
	rule.prelude = create_buffer();
	rule.name = par.value;
	rule.value = null;

	for (;;) {
		var token = next_token(par);
		switch (token) {
			case TOKEN_SEMICOLON, TOKEN_EOF:
				return rule;

			case TOKEN_CURLY_LBRACKET:
				rule.value = consume_simple_block(par);
				return rule;

			case COMPONENT_SIMPLE_BLOCK:
				if ((par.value as SimpleBlock).associated_token == TOKEN_CURLY_LBRACKET) {
					rule.value = par.value;
					return rule;
				}
				break;
		}
		back_token(par);
		add_token(rule.prelude, consume_component_value(par) as [Token]);
	}
}

function @consume_qualified_rule(par: Parser): Rule
{
	var rule = new Rule;
	rule.prelude = create_buffer();
	rule.value = null;
	
	for (;;) {
		var token = next_token(par);
		switch (token) {
			case TOKEN_EOF:
				return null;

			case TOKEN_CURLY_LBRACKET:
				rule.value = consume_simple_block(par);
				return rule;

			case COMPONENT_SIMPLE_BLOCK:
				if ((par.value as SimpleBlock).associated_token == TOKEN_CURLY_LBRACKET) {
					rule.value = par.value;
					return rule;
				}
				break;
		}
		back_token(par);
		add_token(rule.prelude, consume_component_value(par) as [Token]);
	}
}

function @consume_list_of_declarations(par: Parser): Parser
{
	var buf = create_buffer();

	for (;;) {
		var token = next_token(par);
		switch (token) {
			case TOKEN_WHITESPACE, TOKEN_SEMICOLON:
				break;

			case TOKEN_EOF:
				return buf;

			case TOKEN_AT_KEYWORD: {
				var tok = Array::create(Token::SIZE) as [Token];
				tok[0 as Token].type = COMPONENT_RULE;
				tok[0 as Token].value = consume_at_rule(par);
				add_token(buf, tok);
				break;
			}

			case TOKEN_IDENT: {
				var tmp = create_buffer();
				add_token(tmp, par as [Token]);
				token = next_token(par);
				while (token != TOKEN_SEMICOLON && token != TOKEN_EOF) {
					add_token(tmp, par as [Token]);
					token = next_token(par);
				}
				rewind_buffer(tmp);
				next_token(tmp);
				var decl = consume_declaration(tmp);
				if (decl) {
					add_token(buf, decl as [Token]);
				}
				break;
			}

			default: {
				for (;;) {
					consume_component_value(par);
					token = next_token(par);
					if (token == TOKEN_SEMICOLON || token == TOKEN_EOF) {
						break;
					}
					back_token(par);
				}
				break;
			}
		}
	}
}

function @consume_declaration(par: Parser): Declaration
{
	var decl = new Declaration: create_buffer();
	decl.type = COMPONENT_DECLARATION;
	decl.value = decl;
	decl.name = par.value;

	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token != TOKEN_COLON) {
		return null;
	}

	token = next_token(par);
	while (token != TOKEN_EOF) {
		add_token(decl, par as [Token]);
		token = next_token(par);
	}

	var tokens = decl.tokens;
	var count = get_token_count(decl);
	while (count > 0 && tokens[get_token_idx(count-1) as Token].type == TOKEN_WHITESPACE) {
		count--;
	}
	if (count >= 2) {
		var idx = get_token_idx(count-2);
		if (tokens[idx as Token].type == TOKEN_DELIM && tokens[idx as Token].value == '!') {
			idx = get_token_idx(count-1);
			if (tokens[idx as Token].type == TOKEN_IDENT) {
				var value = tokens[idx as Token].value as String;
				if (value.length == 9 && value.to_lower_case() == "important") {
					(tokens as Dynamic[]).set_length(get_token_idx(count-2));
					decl.important = true;
				}
			}
		}
	}
	return decl;
}

function @consume_component_value(par: Parser): Parser
{
	var token = next_token(par);
	switch (token) {
		case TOKEN_CURLY_LBRACKET, TOKEN_SQUARE_LBRACKET, TOKEN_LBRACKET:
			return consume_simple_block(par);

		case TOKEN_FUNCTION:
			return consume_function(par);
	}
	return par;
}

function @consume_simple_block(par: Parser): SimpleBlock
{
	var block = new SimpleBlock: create_buffer();
	block.type = COMPONENT_SIMPLE_BLOCK;
	block.value = block;
	block.associated_token = par.type;

	var mirror;
	switch (par.type) {
		case TOKEN_CURLY_LBRACKET:  mirror = TOKEN_CURLY_RBRACKET; break;
		case TOKEN_SQUARE_LBRACKET: mirror = TOKEN_SQUARE_RBRACKET; break;
		case TOKEN_LBRACKET:        mirror = TOKEN_RBRACKET; break;
	}

	for (;;) {
		var token = next_token(par);
		if (token == mirror) {
			return block;
		}
		switch (token) {
			case TOKEN_EOF:
				return block;

			default:
				back_token(par);
				add_token(block, consume_component_value(par) as [Token]);
				break;
		}
	}
}

function @consume_function(par: Parser): Function
{
	var func = new Function: create_buffer();
	func.type = COMPONENT_FUNCTION;
	func.value = func;
	func.name = {par.value};

	for (;;) {
		var token = next_token(par);
		switch (token) {
			case TOKEN_EOF, TOKEN_RBRACKET:
				return func;

			default:
				back_token(par);
				add_token(func, consume_component_value(par) as [Token]);
				break;
		}
	}
}

function trim_css_tokens(par: Parser)
{
	var tokens = par.tokens;
	while (tokens.length > 0) {
		if (tokens[tokens.first].type == TOKEN_WHITESPACE) {
			(tokens as Dynamic[]).remove(0, Token::SIZE);
			continue;
		}
		break;
	}
	while (tokens.length > 0) {
		if (tokens[tokens.last].type == TOKEN_WHITESPACE) {
			(tokens as Dynamic[]).remove((tokens as Dynamic[]).length-Token::SIZE, Token::SIZE);
			continue;
		}
		break;
	}
}

function css_tokens_has_variables(par: Parser): Boolean
{
	var tokens = par.tokens;
	foreach (var i in tokens) {
		switch (tokens[i].type) {
			case COMPONENT_FUNCTION: {
				var func = tokens[i].value as Function;
				if (func.name == "var") {
					return true;
				}
				if (css_tokens_has_variables(func)) {
					return true;
				}
				break;
			}
		}
	}
	return false;
}

function serialize_css_tokens(par: Parser): String
{
	var s = {""};
	rewind_buffer(par);
	while (next_token(par) != TOKEN_EOF) {
		//dump_token(par as [Token], 4);
		switch (par.type) {
			case TOKEN_IDENT:           s += par.value as String; break;
			case TOKEN_FUNCTION:        break;
			case TOKEN_AT_KEYWORD:      s[] = '@'; s += par.value as String; break;
			case TOKEN_HASH:            s[] = '#'; s += par.value as String; break;
			case TOKEN_STRING:          s += css_serialize_string(par.value as String); break;
			case TOKEN_BAD_STRING:      break;
			case TOKEN_URL:             s += "url("; s += par.value as String; s[] = ')'; break;
			case TOKEN_BAD_URL:         break;
			case TOKEN_DELIM:           s[] = par.value as Integer; break;
			case TOKEN_NUMBER:          s += (par.value as Number).repr; break;
			case TOKEN_PERCENTAGE:      s += (par.value as Number).repr; s[] = '%'; break;
			case TOKEN_DIMENSION:       s += (par.value as Number).repr; s += (par as [DimensionToken])[0 as DimensionToken].unit; break;

			case TOKEN_UNICODE_RANGE: {
				var unicode_token = par as [UnicodeRangeToken];
				var start_char = unicode_token[0 as UnicodeRangeToken].start_char;
				var end_char = unicode_token[0 as UnicodeRangeToken].end_char;
				s += "U+"+String::from_hex_int(start_char).pad_left(4, '0');
				if (end_char > start_char) {
					s += "-"+String::from_hex_int(end_char).pad_left(4, '0');
				}
				break;
			}

			case TOKEN_INCLUDE_MATCH:   s += "~="; break;
			case TOKEN_DASH_MATCH:      s += "|="; break;
			case TOKEN_PREFIX_MATCH:    s += "^="; break;
			case TOKEN_SUFFIX_MATCH:    s += "$="; break;
			case TOKEN_SUBSTRING_MATCH: s += "*="; break;
			case TOKEN_COLUMN:          s += "||"; break;
			case TOKEN_WHITESPACE:      s[] = ' '; break;
			case TOKEN_CDO:             s += "<!--"; break;
			case TOKEN_CDC:             s += "-->"; break;
			case TOKEN_COLON:           s[] = ':'; break;
			case TOKEN_SEMICOLON:       s[] = ';'; break;
			case TOKEN_COMMA:           s[] = ','; break;
			case TOKEN_SQUARE_LBRACKET: s[] = '['; break;
			case TOKEN_SQUARE_RBRACKET: s[] = ']'; break;
			case TOKEN_LBRACKET:        s[] = '('; break;
			case TOKEN_RBRACKET:        s[] = ')'; break;
			case TOKEN_CURLY_LBRACKET:  s[] = '{'; break;
			case TOKEN_CURLY_RBRACKET:  s[] = '}'; break;

			case COMPONENT_FUNCTION: {
				var func = par.value as Function;
		        s += func.name;
				s[] = '(';
				s += serialize_css_tokens(func);
				s[] = ')';
				break;
			}
		}
	}
	//log("s="+s);
	return s;
}

function is_anb_syntax_start(par: Parser): Boolean
{
	switch (par.type) {
		case TOKEN_IDENT: {
			var lc = (par.value as String).to_lower_case();
			if (lc == "odd") {
				return true;
			}
			if (lc == "even") {
				return true;
			}
			if (lc == "n") {
				return true;
			}
			if (lc == "-n") {
				return true;
			}
			if (lc == "n-") {
				return true;
			}
			if (lc == "-n-") {
				return true;
			}
			if (lc.starts_with("n-")) {
				var (r, e) = String::parse_int(lc.substring(1));
				return !e;
			}
			if (lc.starts_with("-n-")) {
				var (r, e) = String::parse_int(lc.substring(2));
				return !e;
			}
			break;
		}

		case TOKEN_NUMBER: {
			var val = par.value as Number;
			if (!val.is_number) {
				return true;
			}
			break;
		}

		case TOKEN_DIMENSION: {
			var val = par.value as Number;
			var unit = ((par as [DimensionToken])[0 as DimensionToken].unit as String).to_lower_case();
			if (val.is_number) break;

			if (unit == "n") {
				return true;
			}
			if (unit == "n-") {
				return true;
			}
			if (unit.starts_with("n-")) {
				var (r, e) = String::parse_int(unit.substring(1));
				return !e;
			}
			break;
		}

		case TOKEN_DELIM: {
			if (par.value == '+') {
				return true;
			}
			break;
		}
	}

	return false;
}

function parse_anb_syntax(par: Parser): ANB
{
	var token = next_token(par);
	switch (token) {
		case TOKEN_IDENT: {
			var lc = (par.value as String).to_lower_case();
			if (lc == "odd") {
				return ANB::create(2, 1);
			}
			if (lc == "even") {
				return ANB::create(2, 0);
			}
			if (lc == "n") {
				var result = parse_anb_plusminus(par, 1);
				if (result) return result;
				result = parse_anb_signed_integer(par, 1);
				if (result) return result;
				return ANB::create(1, 0);
			}
			if (lc == "-n") {
				var result = parse_anb_plusminus(par, -1);
				if (result) return result;
				result = parse_anb_signed_integer(par, -1);
				if (result) return result;
				return ANB::create(-1, 0);
			}
			if (lc == "n-") {
				return parse_anb_signless_integer(par, 1, true);
			}
			if (lc == "-n-") {
				return parse_anb_signless_integer(par, -1, true);
			}
			if (lc.starts_with("n-")) {
				return ANB::create(1, String::parse_int(lc.substring(1)));
			}
			if (lc.starts_with("-n-")) {
				return ANB::create(-1, String::parse_int(lc.substring(2)));
			}
			break;
		}

		case TOKEN_NUMBER: {
			var val = par.value as Number;
			if (!val.is_number) {
				return ANB::create(0, val.value as Integer);
			}
			break;
		}

		case TOKEN_DIMENSION: {
			var val = par.value as Number;
			var unit = (par as [DimensionToken])[0 as DimensionToken].unit.to_lower_case();
			if (val.is_number) break;

			if (unit == "n") {
				var result = parse_anb_plusminus(par, val.value);
				if (result) return result;
				result = parse_anb_signed_integer(par, val.value);
				if (result) return result;
				return ANB::create(val.value as Integer, 0);
			}
			if (unit == "n-") {
				return parse_anb_signless_integer(par, val.value as Integer, true);
			}
			if (unit.starts_with("n-")) {
				return ANB::create(val.value as Integer, String::parse_int(unit.substring(1)));
			}
			break;
		}

		case TOKEN_DELIM: {
			if (par.value == '+') {
				token = next_token(par);
				if (token == TOKEN_IDENT) {
					var lc = (par.value as String).to_lower_case();
					if (lc == "n") {
						var result = parse_anb_plusminus(par, 1);
						if (result) return result;
						result = parse_anb_signed_integer(par, 1);
						if (result) return result;
						return ANB::create(1, 0);
					}
					if (lc == "n-") {
						return parse_anb_signless_integer(par, 1, true);
					}
					if (lc.starts_with("n-")) {
						return ANB::create(1, String::parse_int(lc.substring(1)));
					}
				}
			}
			break;
		}
	}

	throw error("syntax error");
}

function @parse_anb_signed_integer(par: Parser, a_value: Integer): ANB
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_NUMBER) {
		var val = par.value as Number;
		if (!val.is_number) {
			if (val.repr[0] == '+' || val.repr[0] == '-') {
				return ANB::create(a_value, val.value);
			}
		}
	}
	back_token(par);
	return null;
}

function @parse_anb_signless_integer(par: Parser, a_value: Integer, neg: Boolean): ANB
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_NUMBER) {
		var val = par.value as Number;
		if (!val.is_number) {
			if (is_digit(val.repr[0])) {
				return ANB::create(a_value, neg? -(val.value as Integer) : (val.value as Integer));
			}
		}
	}
	throw error("syntax error");
}

function @parse_anb_plusminus(par: Parser, a_value: Integer): ANB
{
	var token = next_token(par);
	while (token == TOKEN_WHITESPACE) {
		token = next_token(par);
	}
	if (token == TOKEN_DELIM) {
		if (par.value == '+') {
			return parse_anb_signless_integer(par, a_value, false);
		}
		if (par.value == '-') {
			return parse_anb_signless_integer(par, a_value, true);
		}
	}
	back_token(par);
	return null;
}

function serialize_anb_syntax(anb: ANB): String
{
	var step = anb.step;
	var offset = anb.offset;

	if (step == 0) {
		return {offset};
	}

	var s = {(step+"n")};
	if (offset == 0) {
		return s;
	}
	if (offset > 0) {
		s[] = '+';
	}
	return s+offset;
}

function @assert_anb(value: String, result: ANB)
{
	var par = parser_create(value+"{}", null);
	var rules = parse_stylesheet(par);
	var buf = rules[0].prelude;
	value = to_string(parse_anb_syntax(buf));

	if (next_token(buf) != TOKEN_EOF) {
		throw error("assert failed (trailing data)");
	}
	
	if (value != result) {
		throw error("assert failed (expected "+result+" but got "+value+")");
	}
}

function @assert_anb_invalid(value: String)
{
	var par = parser_create(value+"{}", null);
	var rules = parse_stylesheet(par);
	var buf = rules[0].prelude;
	var (r, e) = parse_anb_syntax(buf);

	if (!e && next_token(buf) != TOKEN_EOF) {
		e = true;
	}
	
	if (!e) {
		throw error("assert failed (expected error but got none)");
	}
}

function test_anb_syntax()
{
	assert_anb("odd", ANB::create(2, 1));
	assert_anb("even", ANB::create(2, 0));
	assert_anb("5", ANB::create(0, 5));
	assert_anb("-5", ANB::create(0, -5));
	assert_anb("5n", ANB::create(5, 0));
	assert_anb("+n", ANB::create(1, 0));
	assert_anb("n", ANB::create(1, 0));
	assert_anb("-n", ANB::create(-1, 0));
	assert_anb("1n-2", ANB::create(1, -2));
	assert_anb("n-2", ANB::create(1, -2));
	assert_anb("+n-2", ANB::create(1, -2));
	assert_anb("-n-2", ANB::create(-1, -2));
	assert_anb("5n+2", ANB::create(5, 2));
	assert_anb("-5n+2", ANB::create(-5, 2));
	assert_anb("5n-2", ANB::create(5, -2));
	assert_anb("-5n-2", ANB::create(-5, -2));
	assert_anb("5n +2", ANB::create(5, 2));
	assert_anb("-5n +2", ANB::create(-5, 2));
	assert_anb("5n -2", ANB::create(5, -2));
	assert_anb("-5n -2", ANB::create(-5, -2));
	assert_anb("n-2", ANB::create(1, -2));
	assert_anb("n+2", ANB::create(1, 2));
	assert_anb("+n-2", ANB::create(1, -2));
	assert_anb("+n+2", ANB::create(1, 2));
	assert_anb("-n-2", ANB::create(-1, -2));
	assert_anb("-n+2", ANB::create(-1, 2));
	assert_anb("n -2", ANB::create(1, -2));
	assert_anb("n +2", ANB::create(1, 2));
	assert_anb("+n -2", ANB::create(1, -2));
	assert_anb("+n +2", ANB::create(1, 2));
	assert_anb("-n -2", ANB::create(-1, -2));
	assert_anb("-n +2", ANB::create(-1, 2));
	assert_anb("5n- 2", ANB::create(5, -2));
	assert_anb("-5n- 2", ANB::create(-5, -2));
	assert_anb("+n- 2", ANB::create(1, -2));
	assert_anb("n- 2", ANB::create(1, -2));
	assert_anb("-n- 2", ANB::create(-1, -2));
	assert_anb("5n + 2", ANB::create(5, 2));
	assert_anb("5n - 2", ANB::create(5, -2));
	assert_anb("+n + 2", ANB::create(1, 2));
	assert_anb("n + 2", ANB::create(1, 2));
	assert_anb("-n + 2", ANB::create(-1, 2));

	// examples:

	assert_anb("2n+0", ANB::create(2, 0));
	assert_anb("4n+1", ANB::create(4, 1));
	assert_anb("-n+6", ANB::create(-1, 6));
	assert_anb("0n+5", ANB::create(0, 5));
	assert_anb("5", ANB::create(0, 5));
	assert_anb("1n+0", ANB::create(1, 0));
	assert_anb("n+0", ANB::create(1, 0));
	assert_anb("n", ANB::create(1, 0));
	assert_anb("2n+0", ANB::create(2, 0));
	assert_anb("2n", ANB::create(2, 0));
	assert_anb("3n + 1", ANB::create(3, 1));
	assert_anb("+3n - 2", ANB::create(3, -2));
	assert_anb("-n+ 6", ANB::create(-1, 6));

	assert_anb_invalid("3 n");
	assert_anb_invalid("+ 2n");
	assert_anb_invalid("+ 2");
}

function css_escape(value: String): String
{
	var s = {""};
	for (var i=0; i<value.length; i++) {
		var c = value[i];
		switch (c) {
			case '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '.', '/', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '`', '{', '|', '}', '~':
				s[] = '\\';
				s[] = c;
				break;

			case ':':
				// compatibility for IE < 8:
				array_append(s, "\\3A ");
				break;

			case 0: s += "\\FFFD "; break;
			case 1 .. 9: s += "\\0"; s[] = c + '0'; s[] = ' '; break;
			case 10 .. 15: s += "\\0"; s[] = (c - 10) + 'A'; s[] = ' '; break;
			case 16 .. 25: s += "\\1"; s[] = (c - 16) + '0'; s[] = ' '; break;
			case 26 .. 31: s += "\\1"; s[] = (c - 26) + 'A'; s[] = ' '; break;

			default:
				s[] = c;
				break;
		}
	}
	return s;
}

function css_serialize_namespace(value: String): String
{
	if (value == "*") {
		return value;
	}
	return css_escape(value);
}

function css_serialize_type(value: String): String
{
	if (value == "*") {
		return value;
	}
	return css_escape(value);
}

function css_serialize_string(value: String): String
{
	var s = {"\""};
	for (var i=0; i<value.length; i++) {
		var c = value[i];
		switch (c) {
			case '"', '\\', '<', '>':
				s[] = '\\';
				s[] = c;
				break;

			case 0: s += "\\FFFD "; break;
			case 1 .. 9: s += "\\0"; s[] = c + '0'; s[] = ' '; break;
			case 10 .. 15: s += "\\0"; s[] = (c - 10) + 'A'; s[] = ' '; break;
			case 16 .. 25: s += "\\1"; s[] = (c - 16) + '0'; s[] = ' '; break;
			case 26 .. 31: s += "\\1"; s[] = (c - 26) + 'A'; s[] = ' '; break;

			default:
				s[] = c;
				break;
		}
	}
	s[] = '"';
	return s;
}
