/*
 * FixBrowser v0.4 - https://www.fixbrowser.org/
 * Copyright (c) 2018-2025 Martin Dvorak <jezek2@advel.cz>
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from
 * the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

use "macros";

const {
	@TOK_IDENT,
	@TOK_FUNC_REF,
	@TOK_NUMBER,
	@TOK_HEX_NUMBER,
	@TOK_FLOAT_NUMBER,
	@TOK_CHAR,
	@TOK_STRING,
	@TOK_UNKNOWN,

	@KW_DO,
	@KW_IF,
	@KW_FOR,
	@KW_USE,
	@KW_VAR,
	@KW_CASE,
	@KW_ELSE,
	@KW_BREAK,
	@KW_CONST,
	@KW_WHILE,
	@KW_IMPORT,
	@KW_RETURN,
	@KW_SWITCH,
	@KW_DEFAULT,
	@KW_CONTINUE,
	@KW_FUNCTION
};

const {
	@TOK_type,
	@TOK_off,
	@TOK_len,
	@TOK_line,
	@TOK_SIZE
};

const @DEBUG = 0;

function process_tokens(fname, tokens, src)
{
	macro match3(c0, c1, c2) {
		src[off] == c0 && src[off+1] == c1 && src[off+2] == c2
	}

	macro match4(c0, c1, c2, c3) {
		match3(c0, c1, c2) && src[off+3] == c3
	}

	macro match5(c0, c1, c2, c3, c4) {
		match4(c0, c1, c2, c3) && src[off+4] == c4
	}

	macro match6(c0, c1, c2, c3, c4, c5) {
		match5(c0, c1, c2, c3, c4) && src[off+5] == c5
	}

	macro match7(c0, c1, c2, c3, c4, c5, c6) {
		match6(c0, c1, c2, c3, c4, c5) && src[off+6] == c6
	}

	for (var i=0; i<length(tokens); i+=TOK_SIZE) {
		switch (tokens[i+TOK_type]) {
			case TOK_IDENT: {
				var match = false;
				switch (tokens[i+TOK_len]) {
					case 3: {
						var off = tokens[i+TOK_off];
						if (match3('d', 'a', 'y')) {
							match = true;
						}
						break;
					}

					case 4: {
						var off = tokens[i+TOK_off];
						if (match4('y', 'e', 'a', 'r')) {
							match = true;
						}
						else if (match4('d', 'a', 'y', 's')) {
							match = true;
						}
						else if (match4('h', 'o', 'u', 'r')) {
							match = true;
						}
						break;
					}

					case 5: {
						var off = tokens[i+TOK_off];
						if (match5('y', 'e', 'a', 'r', 's')) {
							match = true;
						}
						else if (match5('m', 'o', 'n', 't', 'h')) {
							match = true;
						}
						else if (match5('h', 'o', 'u', 'r', 's')) {
							match = true;
						}
						break;
					}

					case 6: {
						var off = tokens[i+TOK_off];
						if (match6('m', 'o', 'n', 't', 'h', 's')) {
							match = true;
						}
						else if (match6('m', 'i', 'n', 'u', 't', 'e')) {
							match = true;
						}
						else if (match6('s', 'e', 'c', 'o', 'n', 'd')) {
							match = true;
						}
						break;
					}

					case 7: {
						var off = tokens[i+TOK_off];
						if (match7('m', 'i', 'n', 'u', 't', 'e', 's')) {
							match = true;
						}
						else if (match7('s', 'e', 'c', 'o', 'n', 'd', 's')) {
							match = true;
						}
						break;
					}
				}
				if (match) {
					if (i > 0 && tokens[i-TOK_SIZE+TOK_type] == TOK_NUMBER) {
						i -= TOK_SIZE;
						if (i > 0 && tokens[i-TOK_SIZE+TOK_type] == '-') {
							return 0, error({script_line(tokens[i-TOK_SIZE+TOK_line]), ": negative numbers not supported"});
						}
						i = parse_literal(tokens, src, i - TOK_SIZE) - TOK_SIZE;
					}
				}
				break;
			}
		}
	}

	if (DEBUG) {
		dump_tokens(tokens, src);
		return 0, 1;
	}
}

function @parse_literal(tokens, src, i)
{
	var start = i + TOK_SIZE;
	var result = 0;

	macro singular_check() {
		if (number != 1) {
			return 0, error({script_line(tokens[i+TOK_line]), ": number must be 1 for singular time unit"});
		}
	}

	macro plural_check() {
		if (number == 1) {
			return 0, error({script_line(tokens[i+TOK_line]), ": number must not be 1 for plural time unit"});
		}
	}

	for (;;) {
		i = expect_type(tokens, src, i, TOK_NUMBER, "positive number");
		var (number, e) = string_parse_int(get_token_value(tokens, src, i));
		if (e) {
			return 0, error({script_line(tokens[i+TOK_line]), ": number is too big"});
		}

		i = expect_type(tokens, src, i, TOK_IDENT, "time unit");
		var unit = get_token_value(tokens, src, i);
		if (unit == "years") {
			plural_check();
			(result, e) = check_add_mul(result, number, 365*24*3600);
		}
		else if (unit == "year") {
			singular_check();
			(result, e) = check_add_mul(result, number, 365*24*3600);
		}
		else if (unit == "months") {
			plural_check();
			(result, e) = check_add_mul(result, number, 30*24*3600);
		}
		else if (unit == "month") {
			singular_check();
			(result, e) = check_add_mul(result, number, 30*24*3600);
		}
		else if (unit == "days") {
			plural_check();
			(result, e) = check_add_mul(result, number, 24*3600);
		}
		else if (unit == "day") {
			singular_check();
			(result, e) = check_add_mul(result, number, 24*3600);
		}
		else if (unit == "hours") {
			plural_check();
			(result, e) = check_add_mul(result, number, 3600);
		}
		else if (unit == "hour") {
			singular_check();
			(result, e) = check_add_mul(result, number, 3600);
		}
		else if (unit == "minutes") {
			plural_check();
			(result, e) = check_add_mul(result, number, 60);
		}
		else if (unit == "minute") {
			singular_check();
			(result, e) = check_add_mul(result, number, 60);
		}
		else if (unit == "seconds") {
			plural_check();
			(result, e) = check_add_mul(result, number, 1);
		}
		else if (unit == "second") {
			singular_check();
			(result, e) = check_add_mul(result, number, 1);
		}
		else {
			return 0, error({script_line(tokens[i+TOK_line]), ": unknown time unit"});
		}
		if (e) {
			return 0, error({script_line(tokens[i+TOK_line]), ": time literal is too big"});
		}

		if (i+TOK_SIZE < length(tokens) && tokens[i+TOK_SIZE] == TOK_NUMBER) {
			continue;
		}
		break;
	}

	var result_string = {result};
	array_remove(tokens, start + TOK_SIZE, i - start);
	tokens[start+TOK_off] = length(src);
	tokens[start+TOK_len] = length(result_string);
	array_append(src, result_string);
	return start;
}

function @dump_tokens(tokens, src)
{
	var s = {""};
	var last_line = 1, last_type = -1;
	
	for (var i=0; i<length(tokens); i+=TOK_SIZE) {
		if (last_line != tokens[i+TOK_line]) {
			s[] = '\n';
			last_line = tokens[i+TOK_line];
		}
		else {
			if (last_type < ' ' && tokens[i+TOK_type] < ' ') {
				s[] = ' ';
			}
		}
		array_append(s, src, tokens[i+TOK_off], tokens[i+TOK_len]);
		last_type = tokens[i+TOK_type];
	}
	log(s);
}

function @expect_next(tokens, src, i)
{
	i += TOK_SIZE;
	if (i >= length(tokens)) {
		return 0, error({script_line(tokens[i+TOK_line]), ": unexpected end of file"});
	}
	return i;
}

function @expect_type(tokens, src, i, type, what)
{
	i += TOK_SIZE;
	if (tokens[i+TOK_type] != type) {
		return 0, error({script_line(tokens[i+TOK_line]), ": expected ", what});
	}
	return i;
}

function @expect_symbol(tokens, src, i, sym)
{
	i += TOK_SIZE;
	if (tokens[i+TOK_type] != sym) {
		var s = {" "};
		s[0] = sym;
		return 0, error({script_line(tokens[i+TOK_line]), ": expected '", s, "'"});
	}
	return i;
}

function @expect_expression(tokens, src, i)
{
	var level = 0;
	i += TOK_SIZE;
	for (; i < length(tokens); i += TOK_SIZE) {
		switch (tokens[i]) {
			case '(', '{', '[':
				level++;
				break;
			case ')', '}', ']':
				if (level == 0) {
					return i - TOK_SIZE;
				}
				level--;
				break;
			case ',', ';':
				if (level == 0) {
					return i - TOK_SIZE;
				}
				break;
		}
	}

	return 0, error("unexpected end of file");
}

function @get_token_value(tokens, src, i)
{
	return array_extract(src, tokens[i+TOK_off], tokens[i+TOK_len]);
}

function @get_token_string(tokens, src, i)
{
	return token_parse_string(src, tokens[i+TOK_off], tokens[i+TOK_len]);
}

function @check_add_mul(a, b, c)
{
	return a + b * c;
}
